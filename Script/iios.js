/**************************************
@NameÔºöiiosÁ≠æÂà∞ Â§öË¥¶Âè∑ÁâàÊú¨
@AuthorÔºöËãç‰∫ïÁÅ∞ÁÅ∞
@DateÔºö2023-10-11 12:12:16

ÁΩëÁ´ôÂÖ•Âè£Ôºöwww.iios.fun
ËÑöÊú¨ÂÖºÂÆπÔºöSurge„ÄÅQuantumultX„ÄÅLoon„ÄÅShadowrocket„ÄÅNode.js
Âè™ÊµãËØïËøáQuantumultX„ÄÅloonÂíåÈùíÈæôÔºåÂÖ∂ÂÆÉÁéØÂ¢ÉËØ∑Ëá™Ë°åÂ∞ùËØï

ÈùíÈæôÔºö
1.ÊäìÂåÖwww.iios.funÂüüÂêç‰∏ãÁöÑAuthorizationÔºåÂ°´ÂÜôÂà∞iios_data,Â§öË¥¶Âè∑Áî®@ÂàÜÂâ≤

Surge„ÄÅQuantumultX„ÄÅLoon„ÄÅShadowrocketÔºö
ÂçïË¥¶Âè∑Ôºö
1.Â∞ÜÁ≠æÂà∞ËÑöÊú¨ÊãâÂèñÂà∞Êú¨Âú∞
2.ÊâìÂºÄÁΩëÁ´ôÔºåÈöè‰æøÈÄõÈÄõÔºåÊèêÁ§∫Ëé∑ÂèñcookieÊàêÂäüÂàôÂèØ‰ª•‰ΩøÁî®ËØ•ËÑöÊú¨
3.ÂÖ≥Èó≠Ëé∑ÂèñcookieËÑöÊú¨ÔºåÈò≤Ê≠¢‰∫ßÁîü‰∏çÂøÖË¶ÅÁöÑmitm
Â§öË¥¶Âè∑Ôºö
1.ÊäìÂåÖwww.iios.funÂüüÂêç‰∏ãÁöÑAuthorization
2.ÊâìÂºÄboxjs->ÊàëÁöÑ->Êï∞ÊçÆÊü•ÁúãÂô®->Âú®Êï∞ÊçÆÈîÆËæìÂÖ•iios_data,ÁÇπÂáªVIEW->Âú®Êï∞ÊçÆÂÜÖÂÆπËæìÂÖ•ÊäìÂèñÂà∞ÁöÑAuthorizationÔºåÁÇπÂáª‰øùÂ≠ò„ÄÇ
3.Ëã•ÊúâÂ§öË¥¶Âè∑ÔºåÁî®@ÂàÜÂâ≤ÔºåÂ¶ÇAuthorization@Authorization

------------------------------------------
Loon
------------------------------------------
[Script]
cron "14 0 * * *" script-path=https://raw.githubusercontent.com/Sliverkiss/GoodNight/master/Script/iios.js, timeout=300, tag=iiosÁ≠æÂà∞
http-request ^https:\/\/www\.iios\.fun\/api\/(base|user\/info)$ script-path=https://raw.githubusercontent.com/Sliverkiss/GoodNight/master/Script/iios.js, timeout=10, tag=iiosËé∑Âèñtoken

[MITM]
hostname =www.iios.fun

------------------------------------------
QuantumultX
------------------------------------------
[rewrite_local]
^https:\/\/www\.iios\.fun\/api\/(base|user\/info)$ url script-request-header https://raw.githubusercontent.com/Sliverkiss/GoodNight/master/Script/iios.js

[task_local]
1 0 * * * https://raw.githubusercontent.com/Sliverkiss/GoodNight/master/Script/iios.js, tag=iiosÁ≠æÂà∞, enabled=true

[mitm]
hostname = www.iios.fun
‚ö†Ô∏è„ÄêÂÖçË¥£Â£∞Êòé„Äë
------------------------------------------
1„ÄÅÊ≠§ËÑöÊú¨‰ªÖÁî®‰∫éÂ≠¶‰π†Á†îÁ©∂Ôºå‰∏ç‰øùËØÅÂÖ∂ÂêàÊ≥ïÊÄß„ÄÅÂáÜÁ°ÆÊÄß„ÄÅÊúâÊïàÊÄßÔºåËØ∑Ê†πÊçÆÊÉÖÂÜµËá™Ë°åÂà§Êñ≠ÔºåÊú¨‰∫∫ÂØπÊ≠§‰∏çÊâøÊãÖ‰ªª‰Ωï‰øùËØÅË¥£‰ªª„ÄÇ
2„ÄÅÁî±‰∫éÊ≠§ËÑöÊú¨‰ªÖÁî®‰∫éÂ≠¶‰π†Á†îÁ©∂ÔºåÊÇ®ÂøÖÈ°ªÂú®‰∏ãËΩΩÂêé 24 Â∞èÊó∂ÂÜÖÂ∞ÜÊâÄÊúâÂÜÖÂÆπ‰ªéÊÇ®ÁöÑËÆ°ÁÆóÊú∫ÊàñÊâãÊú∫Êàñ‰ªª‰ΩïÂ≠òÂÇ®ËÆæÂ§á‰∏≠ÂÆåÂÖ®Âà†Èô§ÔºåËã•ËøùÂèçËßÑÂÆöÂºïËµ∑‰ªª‰Ωï‰∫ã‰ª∂Êú¨‰∫∫ÂØπÊ≠§Âùá‰∏çË¥üË¥£„ÄÇ
3„ÄÅËØ∑ÂãøÂ∞ÜÊ≠§ËÑöÊú¨Áî®‰∫é‰ªª‰ΩïÂïÜ‰∏öÊàñÈùûÊ≥ïÁõÆÁöÑÔºåËã•ËøùÂèçËßÑÂÆöËØ∑Ëá™Ë°åÂØπÊ≠§Ë¥üË¥£„ÄÇ
4„ÄÅÊ≠§ËÑöÊú¨Ê∂âÂèäÂ∫îÁî®‰∏éÊú¨‰∫∫Êó†ÂÖ≥ÔºåÊú¨‰∫∫ÂØπÂõ†Ê≠§ÂºïËµ∑ÁöÑ‰ªª‰ΩïÈöêÁßÅÊ≥ÑÊºèÊàñÂÖ∂‰ªñÂêéÊûú‰∏çÊâøÊãÖ‰ªª‰ΩïË¥£‰ªª„ÄÇ
5„ÄÅÊú¨‰∫∫ÂØπ‰ªª‰ΩïËÑöÊú¨ÂºïÂèëÁöÑÈóÆÈ¢òÊ¶Ç‰∏çË¥üË¥£ÔºåÂåÖÊã¨‰ΩÜ‰∏çÈôê‰∫éÁî±ËÑöÊú¨ÈîôËØØÂºïËµ∑ÁöÑ‰ªª‰ΩïÊçüÂ§±ÂíåÊçüÂÆ≥„ÄÇ
6„ÄÅÂ¶ÇÊûú‰ªª‰ΩïÂçï‰ΩçÊàñ‰∏™‰∫∫ËÆ§‰∏∫Ê≠§ËÑöÊú¨ÂèØËÉΩÊ∂âÂ´å‰æµÁäØÂÖ∂ÊùÉÂà©ÔºåÂ∫îÂèäÊó∂ÈÄöÁü•Âπ∂Êèê‰æõË∫´‰ªΩËØÅÊòéÔºåÊâÄÊúâÊùÉËØÅÊòéÔºåÊàë‰ª¨Â∞ÜÂú®Êî∂Âà∞ËÆ§ËØÅÊñá‰ª∂Á°ÆËÆ§ÂêéÂà†Èô§Ê≠§ËÑöÊú¨„ÄÇ
7„ÄÅÊâÄÊúâÁõ¥Êé•ÊàñÈó¥Êé•‰ΩøÁî®„ÄÅÊü•ÁúãÊ≠§ËÑöÊú¨ÁöÑ‰∫∫ÂùáÂ∫îËØ•‰ªîÁªÜÈòÖËØªÊ≠§Â£∞Êòé„ÄÇÊú¨‰∫∫‰øùÁïôÈöèÊó∂Êõ¥ÊîπÊàñË°•ÂÖÖÊ≠§Â£∞ÊòéÁöÑÊùÉÂà©„ÄÇ‰∏ÄÊó¶ÊÇ®‰ΩøÁî®ÊàñÂ§çÂà∂‰∫ÜÊ≠§ËÑöÊú¨ÔºåÂç≥ËßÜ‰∏∫ÊÇ®Â∑≤Êé•ÂèóÊ≠§ÂÖçË¥£Â£∞Êòé„ÄÇ
******************************************/

const $ = new Env("iiosÁ≠æÂà∞");
const ckName = "iios_data";
//-------------------- ‰∏ÄËà¨‰∏çÂä®ÂèòÈáèÂå∫Âüü -------------------------------------
const Notify = 1;//0‰∏∫ÂÖ≥Èó≠ÈÄöÁü•,1‰∏∫ÊâìÂºÄÈÄöÁü•,ÈªòËÆ§‰∏∫1
const notify = $.isNode() ? require('./sendNotify') : '';
let envSplitor = ["@"]; //Â§öË¥¶Âè∑ÂàÜÈöîÁ¨¶
let userCookie = ($.isNode() ? process.env[ckName] : $.getdata(ckName)) || '';
let userList = [];
let userIdx = 0;
let userCount = 0;
// ‰∏∫ÈÄöÁü•ÂáÜÂ§áÁöÑÁ©∫Êï∞ÁªÑ
$.notifyMsg = [];
//---------------------- Ëá™ÂÆö‰πâÂèòÈáèÂå∫Âüü -----------------------------------
!(async () => {
    if (typeof $request != "undefined") {
        getToken();
        return;
    }
    if (!(await checkEnv())) { throw new Error(`‚ùåÊú™Ê£ÄÊµãÂà∞ckÔºåËØ∑Ê∑ªÂä†ÁéØÂ¢ÉÂèòÈáè`) };
    intrsa();
    intaes();
    if (userList.length > 0) {
        await main();
    }
})()
    .catch((e) => {
        $.log("", `‚ùåÂ§±Ë¥•! ÂéüÂõ†: ${e}!`, "");
    })
    .finally(async () => {
        await SendMsg($.notifyMsg.join('\n'))//Â∏¶‰∏äÊÄªÁªìÊé®ÈÄÅÈÄöÁü•
        $.done(); //Ë∞ÉÁî®Surge„ÄÅQXÂÜÖÈÉ®ÁâπÊúâÁöÑÂáΩÊï∞, Áî®‰∫éÈÄÄÂá∫ËÑöÊú¨ÊâßË°å
    });

//ËÑöÊú¨ÂÖ•Âè£ÂáΩÊï∞main()
async function main() {
    console.log('\n----------iiosÁ≠æÂà∞----------\n');
    let taskall = [];
    for (let user of userList) {
            //ckÊú™ËøáÊúüÔºåÂºÄÂßãÊâßË°å‰ªªÂä°
            userIdx++;
            DoubleLog(`üî∑Ë¥¶Âè∑${userIdx} >> Start work`)
            taskall.push(await signList(user));
    }
    await Promise.all(taskall);
}
//Ëé∑ÂèñCookie
 function getToken() {
    if ($request && $request.method != 'OPTIONS') {
        const ckVal = $request.headers['Authorization'] || $request.headers['authorization'];
        if (ckVal) {
            $.setdata(ckVal, ckName);
            $.msg($.name, "", `Ëé∑ÂèñÁ≠æÂà∞CookieÊàêÂäüüéâ\n+${ckVal}`);
        } else {
            $.msg($.name, "", "ÈîôËØØËé∑ÂèñÁ≠æÂà∞CookieÂ§±Ë¥•");
        }
    }
}
function getKey() {
    for (var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16, t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = ""; r.length < n;) r += t.charAt(Math.random() * t.length);
    return r
}
function getHeaders(Sign,token) {
    return {
        'Content-Type': 'text/plain',
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0.0 Mobile/15E148 Safari/604.1',
        'Sign': Sign,
        'Authorization': token
    }
}

async function signList(token){
    let arr=[2,3];  
    for(let huihuiType of arr){
        await signIn(huihuiType,token);
    }
}

async function signIn(huihuiType,token) {
    return new Promise((resove) => {
        aeskey = getKey();
        Sign = RSA_Public_Encrypt(aeskey);
        url = url = 'https://www.iios.fun/api/task';
        body = `{"type":${huihuiType},"webapp":true}`
        body = AES_Encrypt(body, aeskey);
        headers = getHeaders(Sign,token);
        const rest = {
            url: url,
            body: body,
            headers: headers
        };
        $.post(rest, (err, resp, data) => {
            try {
                data = AES_Decrypt(data, aeskey)
                var obj = JSON.parse(data);
                $.todo=huihuiType==2?'ÊØèÊó•Á≠æÂà∞':'ËßÇÁúãËßÜÈ¢ë'
                if (obj?.success == true) {
                     DoubleLog(`‚úÖ${$.todo}:ÊàêÂäü,Ëé∑Âèñ${obj.result.points}‰∏™ÁßØÂàÜ`);
                } else {
                    DoubleLog(`üî∂${$.todo}:${obj.message}`);
                }
            } catch (e) {
                $.logErr(e, "‚ùåËØ∑ÈáçÊñ∞ÁôªÈôÜÊõ¥Êñ∞Authorization");
            } finally {
                resove()
            }
        })
    })
}
// ÂèåÂπ≥Âè∞logËæìÂá∫
function DoubleLog(data) {
    if ($.isNode()) {
        if (data) {
            console.log(`${data}`);
            $.notifyMsg.push(`${data}`);
        }
    } else {
        console.log(`${data}`);
        $.notifyMsg.push(`${data}`);
    }
}
// ÂèëÈÄÅÊ∂àÊÅØ
async function SendMsg(message) {
    if (!message) return;
    if (Notify > 0) {
        if ($.isNode()) {
            await notify.sendNotify($.name, message)
        } else {
            $.msg($.name, '', message)
        }
    } else {
        console.log(message)
    }
}

//Ê£ÄÊü•ÂèòÈáè
async function checkEnv() {
    if (userCookie) {
        // console.log(userCookie);
        let e = envSplitor[0];
        for (let o of envSplitor)
            if (userCookie.indexOf(o) > -1) {
                e = o;
                break;
            }
        for (let n of userCookie.split(e)) n && userList.push(n);
        userCount = userList.length;
    } else {
        console.log("Êú™ÊâæÂà∞CK");
        return;
    }
    return console.log(`ÂÖ±ÊâæÂà∞${userCount}‰∏™Ë¥¶Âè∑`), true;//true == !0
}
//************#aes
function AES_Encrypt(t, e) { e = huihui.enc.Utf8.parse(e); var r = huihui.enc.Utf8.parse(t); return huihui.AES.encrypt(r, e, { mode: huihui.mode.ECB, padding: huihui.pad.Pkcs7 }).toString() } function AES_Decrypt(t, e) { e = huihui.enc.Utf8.parse(e); var r = t; return huihui.AES.decrypt(r, e, { mode: huihui.mode.ECB, padding: huihui.pad.Pkcs7 }).toString(huihui.enc.Utf8) } function intaes() { var t; huihui = function (t, e) { var r; if ("undefined" != typeof window && window.crypto && (r = window.crypto), "undefined" != typeof self && self.crypto && (r = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (r = globalThis.crypto), !r && "undefined" != typeof window && window.msCrypto && (r = window.msCrypto), !r && "undefined" != typeof global && global.crypto && (r = global.crypto), !r && "function" == typeof require) try { r = require("crypto") } catch (t) { } var i = function () { if (r) { if ("function" == typeof r.getRandomValues) try { return r.getRandomValues(new Uint32Array(1))[0] } catch (t) { } if ("function" == typeof r.randomBytes) try { return r.randomBytes(4).readInt32LE() } catch (t) { } } throw new Error("Native crypto module could not be used to get secure random number.") }, n = Object.create || function () { function t() { } return function (e) { var r; return t.prototype = e, r = new t, t.prototype = null, r } }(), o = {}, c = o.lib = {}, s = c.Base = { extend: function (t) { var e = n(this); return t && e.mixIn(t), e.hasOwnProperty("init") && this.init !== e.init || (e.init = function () { e.$super.init.apply(this, arguments) }), e.init.prototype = e, e.$super = this, e }, create: function () { var t = this.extend(); return t.init.apply(t, arguments), t }, init: function () { }, mixIn: function (t) { for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]); t.hasOwnProperty("toString") && (this.toString = t.toString) }, clone: function () { return this.init.prototype.extend(this) } }, a = c.WordArray = s.extend({ init: function (t, e) { t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length }, toString: function (t) { return (t || h).stringify(this) }, concat: function (t) { var e = this.words, r = t.words, i = this.sigBytes, n = t.sigBytes; if (this.clamp(), i % 4) for (var o = 0; o < n; o++) { var c = r[o >>> 2] >>> 24 - o % 4 * 8 & 255; e[i + o >>> 2] |= c << 24 - (i + o) % 4 * 8 } else for (var s = 0; s < n; s += 4)e[i + s >>> 2] = r[s >>> 2]; return this.sigBytes += n, this }, clamp: function () { var e = this.words, r = this.sigBytes; e[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, e.length = t.ceil(r / 4) }, clone: function () { var t = s.clone.call(this); return t.words = this.words.slice(0), t }, random: function (e) { var r, n = [], o = function (e) { e = e; var r = 987654321, i = 4294967295; return function () { var n = ((r = 36969 * (65535 & r) + (r >> 16) & i) << 16) + (e = 18e3 * (65535 & e) + (e >> 16) & i) & i; return n /= 4294967296, (n += .5) * (t.random() > .5 ? 1 : -1) } }, c = !1; try { i(), c = !0 } catch (t) { } for (var s, u = 0; u < e; u += 4)c ? n.push(i()) : (s = 987654071 * (r = o(4294967296 * (s || t.random())))(), n.push(4294967296 * r() | 0)); return new a.init(n, e) } }), u = o.enc = {}, h = u.Hex = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, i = [], n = 0; n < r; n++) { var o = e[n >>> 2] >>> 24 - n % 4 * 8 & 255; i.push((o >>> 4).toString(16)), i.push((15 & o).toString(16)) } return i.join("") }, parse: function (t) { for (var e = t.length, r = [], i = 0; i < e; i += 2)r[i >>> 3] |= parseInt(t.substr(i, 2), 16) << 24 - i % 8 * 4; return new a.init(r, e / 2) } }, f = u.Latin1 = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, i = [], n = 0; n < r; n++) { var o = e[n >>> 2] >>> 24 - n % 4 * 8 & 255; i.push(String.fromCharCode(o)) } return i.join("") }, parse: function (t) { for (var e = t.length, r = [], i = 0; i < e; i++)r[i >>> 2] |= (255 & t.charCodeAt(i)) << 24 - i % 4 * 8; return new a.init(r, e) } }, p = u.Utf8 = { stringify: function (t) { try { return decodeURIComponent(escape(f.stringify(t))) } catch (t) { throw new Error("Malformed UTF-8 data") } }, parse: function (t) { return f.parse(unescape(encodeURIComponent(t))) } }, d = c.BufferedBlockAlgorithm = s.extend({ reset: function () { this._data = new a.init, this._nDataBytes = 0 }, _append: function (t) { "string" == typeof t && (t = p.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes }, _process: function (e) { var r, i = this._data, n = i.words, o = i.sigBytes, c = this.blockSize, s = o / (4 * c), u = (s = e ? t.ceil(s) : t.max((0 | s) - this._minBufferSize, 0)) * c, h = t.min(4 * u, o); if (u) { for (var f = 0; f < u; f += c)this._doProcessBlock(n, f); r = n.splice(0, u), i.sigBytes -= h } return new a.init(r, h) }, clone: function () { var t = s.clone.call(this); return t._data = this._data.clone(), t }, _minBufferSize: 0 }), l = (c.Hasher = d.extend({ cfg: s.extend(), init: function (t) { this.cfg = this.cfg.extend(t), this.reset() }, reset: function () { d.reset.call(this), this._doReset() }, update: function (t) { return this._append(t), this._process(), this }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, blockSize: 16, _createHelper: function (t) { return function (e, r) { return new t.init(r).finalize(e) } }, _createHmacHelper: function (t) { return function (e, r) { return new l.HMAC.init(t, r).finalize(e) } } }), o.algo = {}); return o }(Math), function () { var t = huihui, e = t.lib.WordArray; t.enc.Base64 = { stringify: function (t) { var e = t.words, r = t.sigBytes, i = this._map; t.clamp(); for (var n = [], o = 0; o < r; o += 3)for (var c = (e[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (e[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | e[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, s = 0; s < 4 && o + .75 * s < r; s++)n.push(i.charAt(c >>> 6 * (3 - s) & 63)); var a = i.charAt(64); if (a) for (; n.length % 4;)n.push(a); return n.join("") }, parse: function (t) { var r = t.length, i = this._map, n = this._reverseMap; if (!n) { n = this._reverseMap = []; for (var o = 0; o < i.length; o++)n[i.charCodeAt(o)] = o } var c = i.charAt(64); if (c) { var s = t.indexOf(c); -1 !== s && (r = s) } return function (t, r, i) { for (var n = [], o = 0, c = 0; c < r; c++)if (c % 4) { var s = i[t.charCodeAt(c - 1)] << c % 4 * 2, a = i[t.charCodeAt(c)] >>> 6 - c % 4 * 2; n[o >>> 2] |= (s | a) << 24 - o % 4 * 8, o++ } return e.create(n, o) }(t, r, n) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" } }(), huihui.lib.Cipher || function (t) { var e = huihui, r = e.lib, i = r.Base, n = r.WordArray, o = r.BufferedBlockAlgorithm, c = e.enc, s = (c.Utf8, c.Base64), a = e.algo.EvpKDF, u = r.Cipher = o.extend({ cfg: i.extend(), createEncryptor: function (t, e) { return this.create(this._ENC_XFORM_MODE, t, e) }, createDecryptor: function (t, e) { return this.create(this._DEC_XFORM_MODE, t, e) }, init: function (t, e, r) { this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset() }, reset: function () { o.reset.call(this), this._doReset() }, process: function (t) { return this._append(t), this._process() }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function () { function t(t) { return "string" == typeof t ? g : _ } return function (e) { return { encrypt: function (r, i, n) { return t(i).encrypt(e, r, i, n) }, decrypt: function (r, i, n) { return t(i).decrypt(e, r, i, n) } } } }() }), h = (r.StreamCipher = u.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }), e.mode = {}), f = r.BlockCipherMode = i.extend({ createEncryptor: function (t, e) { return this.Encryptor.create(t, e) }, createDecryptor: function (t, e) { return this.Decryptor.create(t, e) }, init: function (t, e) { this._cipher = t, this._iv = e } }), p = h.CBC = function () { var e = f.extend(); function r(e, r, i) { var n, o = this._iv; o ? (n = o, this._iv = t) : n = this._prevBlock; for (var c = 0; c < i; c++)e[r + c] ^= n[c] } return e.Encryptor = e.extend({ processBlock: function (t, e) { var i = this._cipher, n = i.blockSize; r.call(this, t, e, n), i.encryptBlock(t, e), this._prevBlock = t.slice(e, e + n) } }), e.Decryptor = e.extend({ processBlock: function (t, e) { var i = this._cipher, n = i.blockSize, o = t.slice(e, e + n); i.decryptBlock(t, e), r.call(this, t, e, n), this._prevBlock = o } }), e }(), d = (e.pad = {}).Pkcs7 = { pad: function (t, e) { for (var r = 4 * e, i = r - t.sigBytes % r, o = i << 24 | i << 16 | i << 8 | i, c = [], s = 0; s < i; s += 4)c.push(o); var a = n.create(c, i); t.concat(a) }, unpad: function (t) { var e = 255 & t.words[t.sigBytes - 1 >>> 2]; t.sigBytes -= e } }, l = (r.BlockCipher = u.extend({ cfg: u.cfg.extend({ mode: p, padding: d }), reset: function () { var t; u.reset.call(this); var e = this.cfg, r = e.iv, i = e.mode; this._xformMode == this._ENC_XFORM_MODE ? t = i.createEncryptor : (t = i.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == t ? this._mode.init(this, r && r.words) : (this._mode = t.call(i, this, r && r.words), this._mode.__creator = t) }, _doProcessBlock: function (t, e) { this._mode.processBlock(t, e) }, _doFinalize: function () { var t, e = this.cfg.padding; return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize), t = this._process(!0)) : (t = this._process(!0), e.unpad(t)), t }, blockSize: 4 }), r.CipherParams = i.extend({ init: function (t) { this.mixIn(t) }, toString: function (t) { return (t || this.formatter).stringify(this) } })), y = (e.format = {}).OpenSSL = { stringify: function (t) { var e = t.ciphertext, r = t.salt; return (r ? n.create([1398893684, 1701076831]).concat(r).concat(e) : e).toString(s) }, parse: function (t) { var e, r = s.parse(t), i = r.words; return 1398893684 == i[0] && 1701076831 == i[1] && (e = n.create(i.slice(2, 4)), i.splice(0, 4), r.sigBytes -= 16), l.create({ ciphertext: r, salt: e }) } }, _ = r.SerializableCipher = i.extend({ cfg: i.extend({ format: y }), encrypt: function (t, e, r, i) { i = this.cfg.extend(i); var n = t.createEncryptor(r, i), o = n.finalize(e), c = n.cfg; return l.create({ ciphertext: o, key: r, iv: c.iv, algorithm: t, mode: c.mode, padding: c.padding, blockSize: t.blockSize, formatter: i.format }) }, decrypt: function (t, e, r, i) { return i = this.cfg.extend(i), e = this._parse(e, i.format), t.createDecryptor(r, i).finalize(e.ciphertext) }, _parse: function (t, e) { return "string" == typeof t ? e.parse(t, this) : t } }), v = (e.kdf = {}).OpenSSL = { execute: function (t, e, r, i, o) { if (i || (i = n.random(8)), o) c = a.create({ keySize: e + r, hasher: o }).compute(t, i); else var c = a.create({ keySize: e + r }).compute(t, i); var s = n.create(c.words.slice(e), 4 * r); return c.sigBytes = 4 * e, l.create({ key: c, iv: s, salt: i }) } }, g = r.PasswordBasedCipher = _.extend({ cfg: _.cfg.extend({ kdf: v }), encrypt: function (t, e, r, i) { var n = (i = this.cfg.extend(i)).kdf.execute(r, t.keySize, t.ivSize, i.salt, i.hasher); i.iv = n.iv; var o = _.encrypt.call(this, t, e, n.key, i); return o.mixIn(n), o }, decrypt: function (t, e, r, i) { i = this.cfg.extend(i), e = this._parse(e, i.format); var n = i.kdf.execute(r, t.keySize, t.ivSize, e.salt, i.hasher); return i.iv = n.iv, _.decrypt.call(this, t, e, n.key, i) } }) }(), huihui.mode.ECB = ((t = huihui.lib.BlockCipherMode.extend()).Encryptor = t.extend({ processBlock: function (t, e) { this._cipher.encryptBlock(t, e) } }), t.Decryptor = t.extend({ processBlock: function (t, e) { this._cipher.decryptBlock(t, e) } }), t), function () { var t = huihui, e = t.lib.BlockCipher, r = t.algo, i = [], n = [], o = [], c = [], s = [], a = [], u = [], h = [], f = [], p = []; !function () { for (var t = [], e = 0; e < 256; e++)t[e] = e < 128 ? e << 1 : e << 1 ^ 283; var r = 0, d = 0; for (e = 0; e < 256; e++) { var l = d ^ d << 1 ^ d << 2 ^ d << 3 ^ d << 4; l = l >>> 8 ^ 255 & l ^ 99, i[r] = l, n[l] = r; var y = t[r], _ = t[y], v = t[_], g = 257 * t[l] ^ 16843008 * l; o[r] = g << 24 | g >>> 8, c[r] = g << 16 | g >>> 16, s[r] = g << 8 | g >>> 24, a[r] = g, g = 16843009 * v ^ 65537 * _ ^ 257 * y ^ 16843008 * r, u[l] = g << 24 | g >>> 8, h[l] = g << 16 | g >>> 16, f[l] = g << 8 | g >>> 24, p[l] = g, r ? (r = y ^ t[t[t[v ^ y]]], d ^= t[t[d]]) : r = d = 1 } }(); var d = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], l = r.AES = e.extend({ _doReset: function () { if (!this._nRounds || this._keyPriorReset !== this._key) { for (var t = this._keyPriorReset = this._key, e = t.words, r = t.sigBytes / 4, n = 4 * ((this._nRounds = r + 6) + 1), o = this._keySchedule = [], c = 0; c < n; c++)if (c < r) o[c] = e[c]; else { var s = o[c - 1]; c % r ? r > 6 && c % r == 4 && (s = i[s >>> 24] << 24 | i[s >>> 16 & 255] << 16 | i[s >>> 8 & 255] << 8 | i[255 & s]) : (s = i[(s = s << 8 | s >>> 24) >>> 24] << 24 | i[s >>> 16 & 255] << 16 | i[s >>> 8 & 255] << 8 | i[255 & s], s ^= d[c / r | 0] << 24), o[c] = o[c - r] ^ s } for (var a = this._invKeySchedule = [], l = 0; l < n; l++)c = n - l, s = l % 4 ? o[c] : o[c - 4], a[l] = l < 4 || c <= 4 ? s : u[i[s >>> 24]] ^ h[i[s >>> 16 & 255]] ^ f[i[s >>> 8 & 255]] ^ p[i[255 & s]] } }, encryptBlock: function (t, e) { this._doCryptBlock(t, e, this._keySchedule, o, c, s, a, i) }, decryptBlock: function (t, e) { var r = t[e + 1]; t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, u, h, f, p, n), r = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = r }, _doCryptBlock: function (t, e, r, i, n, o, c, s) { for (var a = this._nRounds, u = t[e] ^ r[0], h = t[e + 1] ^ r[1], f = t[e + 2] ^ r[2], p = t[e + 3] ^ r[3], d = 4, l = 1; l < a; l++) { var y = i[u >>> 24] ^ n[h >>> 16 & 255] ^ o[f >>> 8 & 255] ^ c[255 & p] ^ r[d++], _ = i[h >>> 24] ^ n[f >>> 16 & 255] ^ o[p >>> 8 & 255] ^ c[255 & u] ^ r[d++], v = i[f >>> 24] ^ n[p >>> 16 & 255] ^ o[u >>> 8 & 255] ^ c[255 & h] ^ r[d++], g = i[p >>> 24] ^ n[u >>> 16 & 255] ^ o[h >>> 8 & 255] ^ c[255 & f] ^ r[d++]; u = y, h = _, f = v, p = g } y = (s[u >>> 24] << 24 | s[h >>> 16 & 255] << 16 | s[f >>> 8 & 255] << 8 | s[255 & p]) ^ r[d++], _ = (s[h >>> 24] << 24 | s[f >>> 16 & 255] << 16 | s[p >>> 8 & 255] << 8 | s[255 & u]) ^ r[d++], v = (s[f >>> 24] << 24 | s[p >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & h]) ^ r[d++], g = (s[p >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[h >>> 8 & 255] << 8 | s[255 & f]) ^ r[d++], t[e] = y, t[e + 1] = _, t[e + 2] = v, t[e + 3] = g }, keySize: 8 }); t.AES = e._createHelper(l) }() }

//************RSA
function intrsa() { RSA = {}, function (exports) { var window = {}, navigator = {}, dbits; Array.prototype.forEach || (Array.prototype.forEach = function (t, e) { var i, n; if (null == this) throw new TypeError(" this is null or not defined"); var r = Object(this), s = r.length >>> 0; if ("function" != typeof t) throw new TypeError(t + " is not a function"); for (arguments.length > 1 && (i = e), n = 0; n < s;) { var o; n in r && (o = r[n], t.call(i, o, n, r)), n++ } }); var canary = 0xdeadbeefcafe, j_lm = 15715070 == (16777215 & canary); function BigInteger(t, e, i) { null != t && ("number" == typeof t ? this.fromNumber(t, e, i) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e)) } function nbi() { return new BigInteger(null) } function am1(t, e, i, n, r, s) { for (; --s >= 0;) { var o = e * this[t++] + i[n] + r; r = Math.floor(o / 67108864), i[n++] = 67108863 & o } return r } function am2(t, e, i, n, r, s) { for (var o = 32767 & e, h = e >> 15; --s >= 0;) { var a = 32767 & this[t], u = this[t++] >> 15, p = h * a + u * o; r = ((a = o * a + ((32767 & p) << 15) + i[n] + (1073741823 & r)) >>> 30) + (p >>> 15) + h * u + (r >>> 30), i[n++] = 1073741823 & a } return r } function am3(t, e, i, n, r, s) { for (var o = 16383 & e, h = e >> 14; --s >= 0;) { var a = 16383 & this[t], u = this[t++] >> 14, p = h * a + u * o; r = ((a = o * a + ((16383 & p) << 14) + i[n] + r) >> 28) + (p >> 14) + h * u, i[n++] = 268435455 & a } return r } j_lm && "Microsoft Internet Explorer" == navigator.appName ? (BigInteger.prototype.am = am2, dbits = 30) : j_lm && "Netscape" != navigator.appName ? (BigInteger.prototype.am = am1, dbits = 26) : (BigInteger.prototype.am = am3, dbits = 28), BigInteger.prototype.DB = dbits, BigInteger.prototype.DM = (1 << dbits) - 1, BigInteger.prototype.DV = 1 << dbits; var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP), BigInteger.prototype.F1 = BI_FP - dbits, BigInteger.prototype.F2 = 2 * dbits - BI_FP; var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz", BI_RC = new Array, rr, vv; for (rr = "0".charCodeAt(0), vv = 0; vv <= 9; ++vv)BI_RC[rr++] = vv; for (rr = "a".charCodeAt(0), vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv; for (rr = "A".charCodeAt(0), vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv; function int2char(t) { return BI_RM.charAt(t) } function intAt(t, e) { var i = BI_RC[t.charCodeAt(e)]; return null == i ? -1 : i } function bnpCopyTo(t) { for (var e = this.t - 1; e >= 0; --e)t[e] = this[e]; t.t = this.t, t.s = this.s } function bnpFromInt(t) { this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0 } function nbv(t) { var e = nbi(); return e.fromInt(t), e } function bnpFromString(t, e) { var i; if (16 == e) i = 4; else if (8 == e) i = 3; else if (256 == e) i = 8; else if (2 == e) i = 1; else if (32 == e) i = 5; else { if (4 != e) return void this.fromRadix(t, e); i = 2 } this.t = 0, this.s = 0; for (var n = t.length, r = !1, s = 0; --n >= 0;) { var o = 8 == i ? 255 & t[n] : intAt(t, n); o < 0 ? "-" == t.charAt(n) && (r = !0) : (r = !1, 0 == s ? this[this.t++] = o : s + i > this.DB ? (this[this.t - 1] |= (o & (1 << this.DB - s) - 1) << s, this[this.t++] = o >> this.DB - s) : this[this.t - 1] |= o << s, (s += i) >= this.DB && (s -= this.DB)) } 8 == i && 0 != (128 & t[0]) && (this.s = -1, s > 0 && (this[this.t - 1] |= (1 << this.DB - s) - 1 << s)), this.clamp(), r && BigInteger.ZERO.subTo(this, this) } function bnpClamp() { for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;)--this.t } function bnToString(t) { if (this.s < 0) return "-" + this.negate().toString(t); var e; if (16 == t) e = 4; else if (8 == t) e = 3; else if (2 == t) e = 1; else if (32 == t) e = 5; else { if (4 != t) return this.toRadix(t); e = 2 } var i, n = (1 << e) - 1, r = !1, s = "", o = this.t, h = this.DB - o * this.DB % e; if (o-- > 0) for (h < this.DB && (i = this[o] >> h) > 0 && (r = !0, s = int2char(i)); o >= 0;)h < e ? (i = (this[o] & (1 << h) - 1) << e - h, i |= this[--o] >> (h += this.DB - e)) : (i = this[o] >> (h -= e) & n, h <= 0 && (h += this.DB, --o)), i > 0 && (r = !0), r && (s += int2char(i)); return r ? s : "0" } function bnNegate() { var t = nbi(); return BigInteger.ZERO.subTo(this, t), t } function bnAbs() { return this.s < 0 ? this.negate() : this } function bnCompareTo(t) { var e = this.s - t.s; if (0 != e) return e; var i = this.t; if (0 != (e = i - t.t)) return this.s < 0 ? -e : e; for (; --i >= 0;)if (0 != (e = this[i] - t[i])) return e; return 0 } function nbits(t) { var e, i = 1; return 0 != (e = t >>> 16) && (t = e, i += 16), 0 != (e = t >> 8) && (t = e, i += 8), 0 != (e = t >> 4) && (t = e, i += 4), 0 != (e = t >> 2) && (t = e, i += 2), 0 != (e = t >> 1) && (t = e, i += 1), i } function bnBitLength() { return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM) } function bnpDLShiftTo(t, e) { var i; for (i = this.t - 1; i >= 0; --i)e[i + t] = this[i]; for (i = t - 1; i >= 0; --i)e[i] = 0; e.t = this.t + t, e.s = this.s } function bnpDRShiftTo(t, e) { for (var i = t; i < this.t; ++i)e[i - t] = this[i]; e.t = Math.max(this.t - t, 0), e.s = this.s } function bnpLShiftTo(t, e) { var i, n = t % this.DB, r = this.DB - n, s = (1 << r) - 1, o = Math.floor(t / this.DB), h = this.s << n & this.DM; for (i = this.t - 1; i >= 0; --i)e[i + o + 1] = this[i] >> r | h, h = (this[i] & s) << n; for (i = o - 1; i >= 0; --i)e[i] = 0; e[o] = h, e.t = this.t + o + 1, e.s = this.s, e.clamp() } function bnpRShiftTo(t, e) { e.s = this.s; var i = Math.floor(t / this.DB); if (i >= this.t) e.t = 0; else { var n = t % this.DB, r = this.DB - n, s = (1 << n) - 1; e[0] = this[i] >> n; for (var o = i + 1; o < this.t; ++o)e[o - i - 1] |= (this[o] & s) << r, e[o - i] = this[o] >> n; n > 0 && (e[this.t - i - 1] |= (this.s & s) << r), e.t = this.t - i, e.clamp() } } function bnpSubTo(t, e) { for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r;)n += this[i] - t[i], e[i++] = n & this.DM, n >>= this.DB; if (t.t < this.t) { for (n -= t.s; i < this.t;)n += this[i], e[i++] = n & this.DM, n >>= this.DB; n += this.s } else { for (n += this.s; i < t.t;)n -= t[i], e[i++] = n & this.DM, n >>= this.DB; n -= t.s } e.s = n < 0 ? -1 : 0, n < -1 ? e[i++] = this.DV + n : n > 0 && (e[i++] = n), e.t = i, e.clamp() } function bnpMultiplyTo(t, e) { var i = this.abs(), n = t.abs(), r = i.t; for (e.t = r + n.t; --r >= 0;)e[r] = 0; for (r = 0; r < n.t; ++r)e[r + i.t] = i.am(0, n[r], e, r, 0, i.t); e.s = 0, e.clamp(), this.s != t.s && BigInteger.ZERO.subTo(e, e) } function bnpSquareTo(t) { for (var e = this.abs(), i = t.t = 2 * e.t; --i >= 0;)t[i] = 0; for (i = 0; i < e.t - 1; ++i) { var n = e.am(i, e[i], t, 2 * i, 0, 1); (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, n, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV, t[i + e.t + 1] = 1) } t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), t.s = 0, t.clamp() } function bnpDivRemTo(t, e, i) { var n = t.abs(); if (!(n.t <= 0)) { var r = this.abs(); if (r.t < n.t) return null != e && e.fromInt(0), void (null != i && this.copyTo(i)); null == i && (i = nbi()); var s = nbi(), o = this.s, h = t.s, a = this.DB - nbits(n[n.t - 1]); a > 0 ? (n.lShiftTo(a, s), r.lShiftTo(a, i)) : (n.copyTo(s), r.copyTo(i)); var u = s.t, p = s[u - 1]; if (0 != p) { var c = p * (1 << this.F1) + (u > 1 ? s[u - 2] >> this.F2 : 0), g = this.FV / c, l = (1 << this.F1) / c, f = 1 << this.F2, d = i.t, b = d - u, v = null == e ? nbi() : e; for (s.dlShiftTo(b, v), i.compareTo(v) >= 0 && (i[i.t++] = 1, i.subTo(v, i)), BigInteger.ONE.dlShiftTo(u, v), v.subTo(s, s); s.t < u;)s[s.t++] = 0; for (; --b >= 0;) { var y = i[--d] == p ? this.DM : Math.floor(i[d] * g + (i[d - 1] + f) * l); if ((i[d] += s.am(0, y, i, b, 0, u)) < y) for (s.dlShiftTo(b, v), i.subTo(v, i); i[d] < --y;)i.subTo(v, i) } null != e && (i.drShiftTo(u, e), o != h && BigInteger.ZERO.subTo(e, e)), i.t = u, i.clamp(), a > 0 && i.rShiftTo(a, i), o < 0 && BigInteger.ZERO.subTo(i, i) } } } function bnMod(t) { var e = nbi(); return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(BigInteger.ZERO) > 0 && t.subTo(e, e), e } function Classic(t) { this.m = t } function cConvert(t) { return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t } function cRevert(t) { return t } function cReduce(t) { t.divRemTo(this.m, null, t) } function cMulTo(t, e, i) { t.multiplyTo(e, i), this.reduce(i) } function cSqrTo(t, e) { t.squareTo(e), this.reduce(e) } function bnpInvDigit() { if (this.t < 1) return 0; var t = this[0]; if (0 == (1 & t)) return 0; var e = 3 & t; return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e } function Montgomery(t) { this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t } function montConvert(t) { var e = nbi(); return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(BigInteger.ZERO) > 0 && this.m.subTo(e, e), e } function montRevert(t) { var e = nbi(); return t.copyTo(e), this.reduce(e), e } function montReduce(t) { for (; t.t <= this.mt2;)t[t.t++] = 0; for (var e = 0; e < this.m.t; ++e) { var i = 32767 & t[e], n = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM; for (t[i = e + this.m.t] += this.m.am(0, n, t, e, 0, this.m.t); t[i] >= t.DV;)t[i] -= t.DV, t[++i]++ } t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t) } function montSqrTo(t, e) { t.squareTo(e), this.reduce(e) } function montMulTo(t, e, i) { t.multiplyTo(e, i), this.reduce(i) } function bnpIsEven() { return 0 == (this.t > 0 ? 1 & this[0] : this.s) } function bnpExp(t, e) { if (t > 4294967295 || t < 1) return BigInteger.ONE; var i = nbi(), n = nbi(), r = e.convert(this), s = nbits(t) - 1; for (r.copyTo(i); --s >= 0;)if (e.sqrTo(i, n), (t & 1 << s) > 0) e.mulTo(n, r, i); else { var o = i; i = n, n = o } return e.revert(i) } function bnModPowInt(t, e) { var i; return i = t < 256 || e.isEven() ? new Classic(e) : new Montgomery(e), this.exp(t, i) } function bnClone() { var t = nbi(); return this.copyTo(t), t } function bnIntValue() { if (this.s < 0) { if (1 == this.t) return this[0] - this.DV; if (0 == this.t) return -1 } else { if (1 == this.t) return this[0]; if (0 == this.t) return 0 } return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0] } function bnByteValue() { return 0 == this.t ? this.s : this[0] << 24 >> 24 } function bnShortValue() { return 0 == this.t ? this.s : this[0] << 16 >> 16 } function bnpChunkSize(t) { return Math.floor(Math.LN2 * this.DB / Math.log(t)) } function bnSigNum() { return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1 } function bnpToRadix(t) { if (null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36) return "0"; var e = this.chunkSize(t), i = Math.pow(t, e), n = nbv(i), r = nbi(), s = nbi(), o = ""; for (this.divRemTo(n, r, s); r.signum() > 0;)o = (i + s.intValue()).toString(t).substr(1) + o, r.divRemTo(n, r, s); return s.intValue().toString(t) + o } function bnpFromRadix(t, e) { this.fromInt(0), null == e && (e = 10); for (var i = this.chunkSize(e), n = Math.pow(e, i), r = !1, s = 0, o = 0, h = 0; h < t.length; ++h) { var a = intAt(t, h); a < 0 ? "-" == t.charAt(h) && 0 == this.signum() && (r = !0) : (o = e * o + a, ++s >= i && (this.dMultiply(n), this.dAddOffset(o, 0), s = 0, o = 0)) } s > 0 && (this.dMultiply(Math.pow(e, s)), this.dAddOffset(o, 0)), r && BigInteger.ZERO.subTo(this, this) } function bnpFromNumber(t, e, i) { if ("number" == typeof e) if (t < 2) this.fromInt(1); else for (this.fromNumber(t, i), this.testBit(t - 1) || this.bitwiseTo(BigInteger.ONE.shiftLeft(t - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e);)this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(BigInteger.ONE.shiftLeft(t - 1), this); else { var n = new Array, r = 7 & t; n.length = 1 + (t >> 3), e.nextBytes(n), r > 0 ? n[0] &= (1 << r) - 1 : n[0] = 0, this.fromString(n, 256) } } function bnToByteArray() { var t = this.t, e = new Array; e[0] = this.s; var i, n = this.DB - t * this.DB % 8, r = 0; if (t-- > 0) for (n < this.DB && (i = this[t] >> n) != (this.s & this.DM) >> n && (e[r++] = i | this.s << this.DB - n); t >= 0;)n < 8 ? (i = (this[t] & (1 << n) - 1) << 8 - n, i |= this[--t] >> (n += this.DB - 8)) : (i = this[t] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --t)), 0 != (128 & i) && (i |= -256), 0 == r && (128 & this.s) != (128 & i) && ++r, (r > 0 || i != this.s) && (e[r++] = i); return e } function bnEquals(t) { return 0 == this.compareTo(t) } function bnMin(t) { return this.compareTo(t) < 0 ? this : t } function bnMax(t) { return this.compareTo(t) > 0 ? this : t } function bnpBitwiseTo(t, e, i) { var n, r, s = Math.min(t.t, this.t); for (n = 0; n < s; ++n)i[n] = e(this[n], t[n]); if (t.t < this.t) { for (r = t.s & this.DM, n = s; n < this.t; ++n)i[n] = e(this[n], r); i.t = this.t } else { for (r = this.s & this.DM, n = s; n < t.t; ++n)i[n] = e(r, t[n]); i.t = t.t } i.s = e(this.s, t.s), i.clamp() } function op_and(t, e) { return t & e } function bnAnd(t) { var e = nbi(); return this.bitwiseTo(t, op_and, e), e } function op_or(t, e) { return t | e } function bnOr(t) { var e = nbi(); return this.bitwiseTo(t, op_or, e), e } function op_xor(t, e) { return t ^ e } function bnXor(t) { var e = nbi(); return this.bitwiseTo(t, op_xor, e), e } function op_andnot(t, e) { return t & ~e } function bnAndNot(t) { var e = nbi(); return this.bitwiseTo(t, op_andnot, e), e } function bnNot() { for (var t = nbi(), e = 0; e < this.t; ++e)t[e] = this.DM & ~this[e]; return t.t = this.t, t.s = ~this.s, t } function bnShiftLeft(t) { var e = nbi(); return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e } function bnShiftRight(t) { var e = nbi(); return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e } function lbit(t) { if (0 == t) return -1; var e = 0; return 0 == (65535 & t) && (t >>= 16, e += 16), 0 == (255 & t) && (t >>= 8, e += 8), 0 == (15 & t) && (t >>= 4, e += 4), 0 == (3 & t) && (t >>= 2, e += 2), 0 == (1 & t) && ++e, e } function bnGetLowestSetBit() { for (var t = 0; t < this.t; ++t)if (0 != this[t]) return t * this.DB + lbit(this[t]); return this.s < 0 ? this.t * this.DB : -1 } function cbit(t) { for (var e = 0; 0 != t;)t &= t - 1, ++e; return e } function bnBitCount() { for (var t = 0, e = this.s & this.DM, i = 0; i < this.t; ++i)t += cbit(this[i] ^ e); return t } function bnTestBit(t) { var e = Math.floor(t / this.DB); return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB) } function bnpChangeBit(t, e) { var i = BigInteger.ONE.shiftLeft(t); return this.bitwiseTo(i, e, i), i } function bnSetBit(t) { return this.changeBit(t, op_or) } function bnClearBit(t) { return this.changeBit(t, op_andnot) } function bnFlipBit(t) { return this.changeBit(t, op_xor) } function bnpAddTo(t, e) { for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r;)n += this[i] + t[i], e[i++] = n & this.DM, n >>= this.DB; if (t.t < this.t) { for (n += t.s; i < this.t;)n += this[i], e[i++] = n & this.DM, n >>= this.DB; n += this.s } else { for (n += this.s; i < t.t;)n += t[i], e[i++] = n & this.DM, n >>= this.DB; n += t.s } e.s = n < 0 ? -1 : 0, n > 0 ? e[i++] = n : n < -1 && (e[i++] = this.DV + n), e.t = i, e.clamp() } function bnAdd(t) { var e = nbi(); return this.addTo(t, e), e } function bnSubtract(t) { var e = nbi(); return this.subTo(t, e), e } function bnMultiply(t) { var e = nbi(); return this.multiplyTo(t, e), e } function bnSquare() { var t = nbi(); return this.squareTo(t), t } function bnDivide(t) { var e = nbi(); return this.divRemTo(t, e, null), e } function bnRemainder(t) { var e = nbi(); return this.divRemTo(t, null, e), e } function bnDivideAndRemainder(t) { var e = nbi(), i = nbi(); return this.divRemTo(t, e, i), new Array(e, i) } function bnpDMultiply(t) { this[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp() } function bnpDAddOffset(t, e) { if (0 != t) { for (; this.t <= e;)this[this.t++] = 0; for (this[e] += t; this[e] >= this.DV;)this[e] -= this.DV, ++e >= this.t && (this[this.t++] = 0), ++this[e] } } function NullExp() { } function nNop(t) { return t } function nMulTo(t, e, i) { t.multiplyTo(e, i) } function nSqrTo(t, e) { t.squareTo(e) } function bnPow(t) { return this.exp(t, new NullExp) } function bnpMultiplyLowerTo(t, e, i) { var n, r = Math.min(this.t + t.t, e); for (i.s = 0, i.t = r; r > 0;)i[--r] = 0; for (n = i.t - this.t; r < n; ++r)i[r + this.t] = this.am(0, t[r], i, r, 0, this.t); for (n = Math.min(t.t, e); r < n; ++r)this.am(0, t[r], i, r, 0, e - r); i.clamp() } function bnpMultiplyUpperTo(t, e, i) { --e; var n = i.t = this.t + t.t - e; for (i.s = 0; --n >= 0;)i[n] = 0; for (n = Math.max(e - this.t, 0); n < t.t; ++n)i[this.t + n - e] = this.am(e - n, t[n], i, 0, 0, this.t + n - e); i.clamp(), i.drShiftTo(1, i) } function Barrett(t) { this.r2 = nbi(), this.q3 = nbi(), BigInteger.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t } function barrettConvert(t) { if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m); if (t.compareTo(this.m) < 0) return t; var e = nbi(); return t.copyTo(e), this.reduce(e), e } function barrettRevert(t) { return t } function barrettReduce(t) { for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0;)t.dAddOffset(1, this.m.t + 1); for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0;)t.subTo(this.m, t) } function barrettSqrTo(t, e) { t.squareTo(e), this.reduce(e) } function barrettMulTo(t, e, i) { t.multiplyTo(e, i), this.reduce(i) } function bnModPow(t, e) { var i, n, r = t.bitLength(), s = nbv(1); if (r <= 0) return s; i = r < 18 ? 1 : r < 48 ? 3 : r < 144 ? 4 : r < 768 ? 5 : 6, n = r < 8 ? new Classic(e) : e.isEven() ? new Barrett(e) : new Montgomery(e); var o = new Array, h = 3, a = i - 1, u = (1 << i) - 1; if (o[1] = n.convert(this), i > 1) { var p = nbi(); for (n.sqrTo(o[1], p); h <= u;)o[h] = nbi(), n.mulTo(p, o[h - 2], o[h]), h += 2 } var c, g, l = t.t - 1, f = !0, d = nbi(); for (r = nbits(t[l]) - 1; l >= 0;) { for (r >= a ? c = t[l] >> r - a & u : (c = (t[l] & (1 << r + 1) - 1) << a - r, l > 0 && (c |= t[l - 1] >> this.DB + r - a)), h = i; 0 == (1 & c);)c >>= 1, --h; if ((r -= h) < 0 && (r += this.DB, --l), f) o[c].copyTo(s), f = !1; else { for (; h > 1;)n.sqrTo(s, d), n.sqrTo(d, s), h -= 2; h > 0 ? n.sqrTo(s, d) : (g = s, s = d, d = g), n.mulTo(d, o[c], s) } for (; l >= 0 && 0 == (t[l] & 1 << r);)n.sqrTo(s, d), g = s, s = d, d = g, --r < 0 && (r = this.DB - 1, --l) } return n.revert(s) } function bnGCD(t) { var e = this.s < 0 ? this.negate() : this.clone(), i = t.s < 0 ? t.negate() : t.clone(); if (e.compareTo(i) < 0) { var n = e; e = i, i = n } var r = e.getLowestSetBit(), s = i.getLowestSetBit(); if (s < 0) return e; for (r < s && (s = r), s > 0 && (e.rShiftTo(s, e), i.rShiftTo(s, i)); e.signum() > 0;)(r = e.getLowestSetBit()) > 0 && e.rShiftTo(r, e), (r = i.getLowestSetBit()) > 0 && i.rShiftTo(r, i), e.compareTo(i) >= 0 ? (e.subTo(i, e), e.rShiftTo(1, e)) : (i.subTo(e, i), i.rShiftTo(1, i)); return s > 0 && i.lShiftTo(s, i), i } function bnpModInt(t) { if (t <= 0) return 0; var e = this.DV % t, i = this.s < 0 ? t - 1 : 0; if (this.t > 0) if (0 == e) i = this[0] % t; else for (var n = this.t - 1; n >= 0; --n)i = (e * i + this[n]) % t; return i } function bnModInverse(t) { var e = t.isEven(); if (this.isEven() && e || 0 == t.signum()) return BigInteger.ZERO; for (var i = t.clone(), n = this.clone(), r = nbv(1), s = nbv(0), o = nbv(0), h = nbv(1); 0 != i.signum();) { for (; i.isEven();)i.rShiftTo(1, i), e ? (r.isEven() && s.isEven() || (r.addTo(this, r), s.subTo(t, s)), r.rShiftTo(1, r)) : s.isEven() || s.subTo(t, s), s.rShiftTo(1, s); for (; n.isEven();)n.rShiftTo(1, n), e ? (o.isEven() && h.isEven() || (o.addTo(this, o), h.subTo(t, h)), o.rShiftTo(1, o)) : h.isEven() || h.subTo(t, h), h.rShiftTo(1, h); i.compareTo(n) >= 0 ? (i.subTo(n, i), e && r.subTo(o, r), s.subTo(h, s)) : (n.subTo(i, n), e && o.subTo(r, o), h.subTo(s, h)) } return 0 != n.compareTo(BigInteger.ONE) ? BigInteger.ZERO : h.compareTo(t) >= 0 ? h.subtract(t) : h.signum() < 0 ? (h.addTo(t, h), h.signum() < 0 ? h.add(t) : h) : h } Classic.prototype.convert = cConvert, Classic.prototype.revert = cRevert, Classic.prototype.reduce = cReduce, Classic.prototype.mulTo = cMulTo, Classic.prototype.sqrTo = cSqrTo, Montgomery.prototype.convert = montConvert, Montgomery.prototype.revert = montRevert, Montgomery.prototype.reduce = montReduce, Montgomery.prototype.mulTo = montMulTo, Montgomery.prototype.sqrTo = montSqrTo, BigInteger.prototype.copyTo = bnpCopyTo, BigInteger.prototype.fromInt = bnpFromInt, BigInteger.prototype.fromString = bnpFromString, BigInteger.prototype.clamp = bnpClamp, BigInteger.prototype.dlShiftTo = bnpDLShiftTo, BigInteger.prototype.drShiftTo = bnpDRShiftTo, BigInteger.prototype.lShiftTo = bnpLShiftTo, BigInteger.prototype.rShiftTo = bnpRShiftTo, BigInteger.prototype.subTo = bnpSubTo, BigInteger.prototype.multiplyTo = bnpMultiplyTo, BigInteger.prototype.squareTo = bnpSquareTo, BigInteger.prototype.divRemTo = bnpDivRemTo, BigInteger.prototype.invDigit = bnpInvDigit, BigInteger.prototype.isEven = bnpIsEven, BigInteger.prototype.exp = bnpExp, BigInteger.prototype.toString = bnToString, BigInteger.prototype.negate = bnNegate, BigInteger.prototype.abs = bnAbs, BigInteger.prototype.compareTo = bnCompareTo, BigInteger.prototype.bitLength = bnBitLength, BigInteger.prototype.mod = bnMod, BigInteger.prototype.modPowInt = bnModPowInt, BigInteger.ZERO = nbv(0), BigInteger.ONE = nbv(1), NullExp.prototype.convert = nNop, NullExp.prototype.revert = nNop, NullExp.prototype.mulTo = nMulTo, NullExp.prototype.sqrTo = nSqrTo, Barrett.prototype.convert = barrettConvert, Barrett.prototype.revert = barrettRevert, Barrett.prototype.reduce = barrettReduce, Barrett.prototype.mulTo = barrettMulTo, Barrett.prototype.sqrTo = barrettSqrTo; var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; function bnIsProbablePrime(t) { var e, i = this.abs(); if (1 == i.t && i[0] <= lowprimes[lowprimes.length - 1]) { for (e = 0; e < lowprimes.length; ++e)if (i[0] == lowprimes[e]) return !0; return !1 } if (i.isEven()) return !1; for (e = 1; e < lowprimes.length;) { for (var n = lowprimes[e], r = e + 1; r < lowprimes.length && n < lplim;)n *= lowprimes[r++]; for (n = i.modInt(n); e < r;)if (n % lowprimes[e++] == 0) return !1 } return i.millerRabin(t) } function bnpMillerRabin(t) { var e = this.subtract(BigInteger.ONE), i = e.getLowestSetBit(); if (i <= 0) return !1; var n = e.shiftRight(i); (t = t + 1 >> 1) > lowprimes.length && (t = lowprimes.length); for (var r = nbi(), s = 0; s < t; ++s) { r.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]); var o = r.modPow(n, this); if (0 != o.compareTo(BigInteger.ONE) && 0 != o.compareTo(e)) { for (var h = 1; h++ < i && 0 != o.compareTo(e);)if (0 == (o = o.modPowInt(2, this)).compareTo(BigInteger.ONE)) return !1; if (0 != o.compareTo(e)) return !1 } } return !0 } function Arcfour() { this.i = 0, this.j = 0, this.S = new Array } function ARC4init(t) { var e, i, n; for (e = 0; e < 256; ++e)this.S[e] = e; for (i = 0, e = 0; e < 256; ++e)i = i + this.S[e] + t[e % t.length] & 255, n = this.S[e], this.S[e] = this.S[i], this.S[i] = n; this.i = 0, this.j = 0 } function ARC4next() { var t; return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t, this.S[t + this.S[this.i] & 255] } function prng_newstate() { return new Arcfour } BigInteger.prototype.chunkSize = bnpChunkSize, BigInteger.prototype.toRadix = bnpToRadix, BigInteger.prototype.fromRadix = bnpFromRadix, BigInteger.prototype.fromNumber = bnpFromNumber, BigInteger.prototype.bitwiseTo = bnpBitwiseTo, BigInteger.prototype.changeBit = bnpChangeBit, BigInteger.prototype.addTo = bnpAddTo, BigInteger.prototype.dMultiply = bnpDMultiply, BigInteger.prototype.dAddOffset = bnpDAddOffset, BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo, BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo, BigInteger.prototype.modInt = bnpModInt, BigInteger.prototype.millerRabin = bnpMillerRabin, BigInteger.prototype.clone = bnClone, BigInteger.prototype.intValue = bnIntValue, BigInteger.prototype.byteValue = bnByteValue, BigInteger.prototype.shortValue = bnShortValue, BigInteger.prototype.signum = bnSigNum, BigInteger.prototype.toByteArray = bnToByteArray, BigInteger.prototype.equals = bnEquals, BigInteger.prototype.min = bnMin, BigInteger.prototype.max = bnMax, BigInteger.prototype.and = bnAnd, BigInteger.prototype.or = bnOr, BigInteger.prototype.xor = bnXor, BigInteger.prototype.andNot = bnAndNot, BigInteger.prototype.not = bnNot, BigInteger.prototype.shiftLeft = bnShiftLeft, BigInteger.prototype.shiftRight = bnShiftRight, BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit, BigInteger.prototype.bitCount = bnBitCount, BigInteger.prototype.testBit = bnTestBit, BigInteger.prototype.setBit = bnSetBit, BigInteger.prototype.clearBit = bnClearBit, BigInteger.prototype.flipBit = bnFlipBit, BigInteger.prototype.add = bnAdd, BigInteger.prototype.subtract = bnSubtract, BigInteger.prototype.multiply = bnMultiply, BigInteger.prototype.divide = bnDivide, BigInteger.prototype.remainder = bnRemainder, BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder, BigInteger.prototype.modPow = bnModPow, BigInteger.prototype.modInverse = bnModInverse, BigInteger.prototype.pow = bnPow, BigInteger.prototype.gcd = bnGCD, BigInteger.prototype.isProbablePrime = bnIsProbablePrime, BigInteger.prototype.square = bnSquare, Arcfour.prototype.init = ARC4init, Arcfour.prototype.next = ARC4next; var rng_psize = 256, rng_state, rng_pool, rng_pptr; if (null == rng_pool) { var t; if (rng_pool = new Array, rng_pptr = 0, window.crypto && window.crypto.getRandomValues) { var z = new Uint32Array(256); for (window.crypto.getRandomValues(z), t = 0; t < z.length; ++t)rng_pool[rng_pptr++] = 255 & z[t] } var onMouseMoveListener = function (t) { if (this.count = this.count || 0, this.count >= 256 || rng_pptr >= rng_psize) window.removeEventListener ? window.removeEventListener("mousemove", onMouseMoveListener, !1) : window.detachEvent && window.detachEvent("onmousemove", onMouseMoveListener); else try { var e = t.x + t.y; rng_pool[rng_pptr++] = 255 & e, this.count += 1 } catch (t) { } }; window.addEventListener ? window.addEventListener("mousemove", onMouseMoveListener, !1) : window.attachEvent && window.attachEvent("onmousemove", onMouseMoveListener) } function rng_get_byte() { if (null == rng_state) { for (rng_state = prng_newstate(); rng_pptr < rng_psize;) { var t = Math.floor(65536 * Math.random()); rng_pool[rng_pptr++] = 255 & t } for (rng_state.init(rng_pool), rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)rng_pool[rng_pptr] = 0; rng_pptr = 0 } return rng_state.next() } function rng_get_bytes(t) { var e; for (e = 0; e < t.length; ++e)t[e] = rng_get_byte() } function SecureRandom() { } function parseBigInt(t, e) { return new BigInteger(t, e) } function linebrk(t, e) { for (var i = "", n = 0; n + e < t.length;)i += t.substring(n, n + e) + "\n", n += e; return i + t.substring(n, t.length) } function byte2Hex(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function pkcs1pad2(t, e, i) { if (e < t.length + 11) return console.error("Message too long for RSA"), null; for (var n = new Array, r = t.length - 1; r >= 0 && e > 0;) { var s = t.charCodeAt(r--); s < 128 ? n[--e] = s : s > 127 && s < 2048 ? (n[--e] = 63 & s | 128, n[--e] = s >> 6 | 192) : (n[--e] = 63 & s | 128, n[--e] = s >> 6 & 63 | 128, n[--e] = s >> 12 | 224) } if (n[--e] = 0, 2 == i) for (var o = new SecureRandom, h = new Array; e > 2;) { for (h[0] = 0; 0 == h[0];)o.nextBytes(h); n[--e] = h[0] } else if (0 == i) n[--e] = 0; else for (; e > 2;)n[--e] = 255; return n[--e] = i, n[--e] = 0, new BigInteger(n) } function RSAKey() { this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null } function RSASetPublic(t, e) { null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = parseBigInt(t, 16), this.e = parseInt(e, 16)) : console.error("Invalid RSA public key") } function RSADoPublic(t) { return t.modPowInt(this.e, this.n) } function RSAPublicEncrypt(t, e) { var i = pkcs1pad2(t, this.n.bitLength() + 7 >> 3, e); if (null == i) return null; var n = this.doPublic(i); if (null == n) return null; var r = n.toString(16); return 0 == (1 & r.length) ? r : "0" + r } function RSAPrivateEncrypt(t, e) { var i = pkcs1pad2(t, this.n.bitLength() + 7 >> 3, e); if (null == i) return null; var n = this.doPrivate(i); if (null == n) return null; var r = n.toString(16); return 0 == (1 & r.length) ? r : "0" + r } function pkcs1unpad2(t, e, i) { var n = t.toByteArray(), r = 0; if (0 == i) r = -1; else { for (; r < n.length && 0 == n[r];)++r; if (n.length - r != e - 1 || n[r] != i) return null; for (++r; 0 != n[r];)if (++r >= n.length) return null } for (var s = ""; ++r < n.length;) { var o = 255 & n[r]; o < 128 ? s += String.fromCharCode(o) : o > 191 && o < 224 ? (s += String.fromCharCode((31 & o) << 6 | 63 & n[r + 1]), ++r) : (s += String.fromCharCode((15 & o) << 12 | (63 & n[r + 1]) << 6 | 63 & n[r + 2]), r += 2) } return s } function RSASetPrivate(t, e, i) { null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = parseBigInt(t, 16), this.e = parseInt(e, 16), this.d = parseBigInt(i, 16)) : console.error("Invalid RSA private key") } function RSASetPrivateEx(t, e, i, n, r, s, o, h) { null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = parseBigInt(t, 16), this.e = parseInt(e, 16), this.d = parseBigInt(i, 16), this.p = parseBigInt(n, 16), this.q = parseBigInt(r, 16), this.dmp1 = parseBigInt(s, 16), this.dmq1 = parseBigInt(o, 16), this.coeff = parseBigInt(h, 16)) : console.error("Invalid RSA private key") } function RSAGenerate(t, e) { var i = new SecureRandom, n = t >> 1; this.e = parseInt(e, 16); for (var r = new BigInteger(e, 16); ;) { for (; this.p = new BigInteger(t - n, 1, i), 0 != this.p.subtract(BigInteger.ONE).gcd(r).compareTo(BigInteger.ONE) || !this.p.isProbablePrime(10);); for (; this.q = new BigInteger(n, 1, i), 0 != this.q.subtract(BigInteger.ONE).gcd(r).compareTo(BigInteger.ONE) || !this.q.isProbablePrime(10);); if (this.p.compareTo(this.q) <= 0) { var s = this.p; this.p = this.q, this.q = s } var o = this.p.subtract(BigInteger.ONE), h = this.q.subtract(BigInteger.ONE), a = o.multiply(h); if (0 == a.gcd(r).compareTo(BigInteger.ONE)) { this.n = this.p.multiply(this.q), this.d = r.modInverse(a), this.dmp1 = this.d.mod(o), this.dmq1 = this.d.mod(h), this.coeff = this.q.modInverse(this.p); break } } } function RSADoPrivate(t) { if (null == this.p || null == this.q) return t.modPow(this.d, this.n); for (var e = t.mod(this.p).modPow(this.dmp1, this.p), i = t.mod(this.q).modPow(this.dmq1, this.q); e.compareTo(i) < 0;)e = e.add(this.p); return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i) } function RSAPrivateDecrypt(t, e) { var i = parseBigInt(t, 16), n = this.doPrivate(i); return null == n ? null : pkcs1unpad2(n, this.n.bitLength() + 7 >> 3, e) } function RSAPublicDecrypt(t, e) { var i = parseBigInt(t, 16), n = this.doPublic(i); return null == n ? null : pkcs1unpad2(n, this.n.bitLength() + 7 >> 3, e) } SecureRandom.prototype.nextBytes = rng_get_bytes, RSAKey.prototype.doPublic = RSADoPublic, RSAKey.prototype.setPublic = RSASetPublic, RSAKey.prototype.encrypt_public = RSAPublicEncrypt, RSAKey.prototype.encrypt_private = RSAPrivateEncrypt, RSAKey.prototype.doPrivate = RSADoPrivate, RSAKey.prototype.setPrivate = RSASetPrivate, RSAKey.prototype.setPrivateEx = RSASetPrivateEx, RSAKey.prototype.generate = RSAGenerate, RSAKey.prototype.decrypt_private = RSAPrivateDecrypt, RSAKey.prototype.decrypt_public = RSAPublicDecrypt, RSAKey.prototype.generateAsync = function (t, e, i) { var n = new SecureRandom, r = t >> 1; this.e = parseInt(e, 16); var s = new BigInteger(e, 16), o = this, h = function () { var e = function () { if (o.p.compareTo(o.q) <= 0) { var t = o.p; o.p = o.q, o.q = t } var e = o.p.subtract(BigInteger.ONE), n = o.q.subtract(BigInteger.ONE), r = e.multiply(n); 0 == r.gcd(s).compareTo(BigInteger.ONE) ? (o.n = o.p.multiply(o.q), o.d = s.modInverse(r), o.dmp1 = o.d.mod(e), o.dmq1 = o.d.mod(n), o.coeff = o.q.modInverse(o.p), setTimeout(function () { i() }, 0)) : setTimeout(h, 0) }, a = function () { o.q = nbi(), o.q.fromNumberAsync(r, 1, n, function () { o.q.subtract(BigInteger.ONE).gcda(s, function (t) { 0 == t.compareTo(BigInteger.ONE) && o.q.isProbablePrime(10) ? setTimeout(e, 0) : setTimeout(a, 0) }) }) }, u = function () { o.p = nbi(), o.p.fromNumberAsync(t - r, 1, n, function () { o.p.subtract(BigInteger.ONE).gcda(s, function (t) { 0 == t.compareTo(BigInteger.ONE) && o.p.isProbablePrime(10) ? setTimeout(a, 0) : setTimeout(u, 0) }) }) }; setTimeout(u, 0) }; setTimeout(h, 0) }, BigInteger.prototype.gcda = function (t, e) { var i = this.s < 0 ? this.negate() : this.clone(), n = t.s < 0 ? t.negate() : t.clone(); if (i.compareTo(n) < 0) { var r = i; i = n, n = r } var s = i.getLowestSetBit(), o = n.getLowestSetBit(); if (o < 0) e(i); else { s < o && (o = s), o > 0 && (i.rShiftTo(o, i), n.rShiftTo(o, n)); var h = function () { (s = i.getLowestSetBit()) > 0 && i.rShiftTo(s, i), (s = n.getLowestSetBit()) > 0 && n.rShiftTo(s, n), i.compareTo(n) >= 0 ? (i.subTo(n, i), i.rShiftTo(1, i)) : (n.subTo(i, n), n.rShiftTo(1, n)), i.signum() > 0 ? setTimeout(h, 0) : (o > 0 && n.lShiftTo(o, n), setTimeout(function () { e(n) }, 0)) }; setTimeout(h, 10) } }, BigInteger.prototype.fromNumberAsync = function (t, e, i, n) { if ("number" == typeof e) if (t < 2) this.fromInt(1); else { this.fromNumber(t, i), this.testBit(t - 1) || this.bitwiseTo(BigInteger.ONE.shiftLeft(t - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); var r = this, s = function () { r.dAddOffset(2, 0), r.bitLength() > t && r.subTo(BigInteger.ONE.shiftLeft(t - 1), r), r.isProbablePrime(e) ? setTimeout(function () { n() }, 0) : setTimeout(s, 0) }; setTimeout(s, 0) } else { var o = new Array, h = 7 & t; o.length = 1 + (t >> 3), e.nextBytes(o), h > 0 ? o[0] &= (1 << h) - 1 : o[0] = 0, this.fromString(o, 256) } }; var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", b64pad = "="; function hex2b64(t) { var e, i, n = ""; for (e = 0; e + 3 <= t.length; e += 3)i = parseInt(t.substring(e, e + 3), 16), n += b64map.charAt(i >> 6) + b64map.charAt(63 & i); for (e + 1 == t.length ? (i = parseInt(t.substring(e, e + 1), 16), n += b64map.charAt(i << 2)) : e + 2 == t.length && (i = parseInt(t.substring(e, e + 2), 16), n += b64map.charAt(i >> 2) + b64map.charAt((3 & i) << 4)); (3 & n.length) > 0;)n += b64pad; return n } function b64tohex(t) { var e, i, n = "", r = 0; for (e = 0; e < t.length && t.charAt(e) != b64pad; ++e)v = b64map.indexOf(t.charAt(e)), v < 0 || (0 == r ? (n += int2char(v >> 2), i = 3 & v, r = 1) : 1 == r ? (n += int2char(i << 2 | v >> 4), i = 15 & v, r = 2) : 2 == r ? (n += int2char(i), n += int2char(v >> 2), i = 3 & v, r = 3) : (n += int2char(i << 2 | v >> 4), n += int2char(15 & v), r = 0)); return 1 == r && (n += int2char(i << 2)), n } function b64toBA(t) { var e, i = b64tohex(t), n = new Array; for (e = 0; 2 * e < i.length; ++e)n[e] = parseInt(i.substring(2 * e, 2 * e + 2), 16); return n } var JSX = JSX || {}; JSX.env = JSX.env || {}; var L = JSX, OP = Object.prototype, FUNCTION_TOSTRING = "[object Function]", ADD = ["toString", "valueOf"]; JSX.env.parseUA = function (t) { var e, i = function (t) { var e = 0; return parseFloat(t.replace(/\./g, function () { return 1 == e++ ? "" : "." })) }, n = { ie: 0, opera: 0, gecko: 0, webkit: 0, chrome: 0, mobile: null, air: 0, ipad: 0, iphone: 0, ipod: 0, ios: null, android: 0, webos: 0, caja: navigator && navigator.cajaVersion, secure: !1, os: null }, r = t || navigator && navigator.userAgent, s = window && window.location, o = s && s.href; return n.secure = o && 0 === o.toLowerCase().indexOf("https"), r && (/windows|win32/i.test(r) ? n.os = "windows" : /macintosh/i.test(r) ? n.os = "macintosh" : /rhino/i.test(r) && (n.os = "rhino"), /KHTML/.test(r) && (n.webkit = 1), (e = r.match(/AppleWebKit\/([^\s]*)/)) && e[1] && (n.webkit = i(e[1]), / Mobile\//.test(r) ? (n.mobile = "Apple", (e = r.match(/OS ([^\s]*)/)) && e[1] && (e = i(e[1].replace("_", "."))), n.ios = e, n.ipad = n.ipod = n.iphone = 0, (e = r.match(/iPad|iPod|iPhone/)) && e[0] && (n[e[0].toLowerCase()] = n.ios)) : ((e = r.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/)) && (n.mobile = e[0]), /webOS/.test(r) && (n.mobile = "WebOS", (e = r.match(/webOS\/([^\s]*);/)) && e[1] && (n.webos = i(e[1]))), / Android/.test(r) && (n.mobile = "Android", (e = r.match(/Android ([^\s]*);/)) && e[1] && (n.android = i(e[1])))), (e = r.match(/Chrome\/([^\s]*)/)) && e[1] ? n.chrome = i(e[1]) : (e = r.match(/AdobeAIR\/([^\s]*)/)) && (n.air = e[0])), n.webkit || ((e = r.match(/Opera[\s\/]([^\s]*)/)) && e[1] ? (n.opera = i(e[1]), (e = r.match(/Version\/([^\s]*)/)) && e[1] && (n.opera = i(e[1])), (e = r.match(/Opera Mini[^;]*/)) && (n.mobile = e[0])) : (e = r.match(/MSIE\s([^;]*)/)) && e[1] ? n.ie = i(e[1]) : (e = r.match(/Gecko\/([^\s]*)/)) && (n.gecko = 1, (e = r.match(/rv:([^\s\)]*)/)) && e[1] && (n.gecko = i(e[1]))))), n }, JSX.env.ua = JSX.env.parseUA(), JSX.isFunction = function (t) { return "function" == typeof t || OP.toString.apply(t) === FUNCTION_TOSTRING }, JSX._IEEnumFix = JSX.env.ua.ie ? function (t, e) { var i, n, r; for (i = 0; i < ADD.length; i += 1)r = e[n = ADD[i]], L.isFunction(r) && r != OP[n] && (t[n] = r) } : function () { }, JSX.extend = function (t, e, i) { if (!e || !t) throw new Error("extend failed, please check that all dependencies are included."); var n, r = function () { }; if (r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t, t.superclass = e.prototype, e.prototype.constructor == OP.constructor && (e.prototype.constructor = e), i) { for (n in i) L.hasOwnProperty(i, n) && (t.prototype[n] = i[n]); L._IEEnumFix(t.prototype, i) } }, "undefined" != typeof KJUR && KJUR || (KJUR = {}), void 0 !== KJUR.asn1 && KJUR.asn1 || (KJUR.asn1 = {}), KJUR.asn1.ASN1Util = new function () { this.integerToByteHex = function (t) { var e = t.toString(16); return e.length % 2 == 1 && (e = "0" + e), e }, this.bigIntToMinTwosComplementsHex = function (t) { var e = t.toString(16); if ("-" != e.substr(0, 1)) e.length % 2 == 1 ? e = "0" + e : e.match(/^[0-7]/) || (e = "00" + e); else { var i = e.substr(1).length; i % 2 == 1 ? i += 1 : e.match(/^[0-7]/) || (i += 2); for (var n = "", r = 0; r < i; r++)n += "f"; e = new BigInteger(n, 16).xor(t).add(BigInteger.ONE).toString(16).replace(/^-/, "") } return e }, this.getPEMStringFromHex = function (t, e) { var i = CryptoJS.enc.Hex.parse(t), n = CryptoJS.enc.Base64.stringify(i).replace(/(.{64})/g, "$1\r\n"); return "-----BEGIN " + e + "-----\r\n" + (n = n.replace(/\r\n$/, "")) + "\r\n-----END " + e + "-----\r\n" } }, KJUR.asn1.ASN1Object = function () { this.getLengthHexFromValue = function () { if (void 0 === this.hV || null == this.hV) throw "this.hV is null or undefined."; if (this.hV.length % 2 == 1) throw "value hex must be even length: n=" + "".length + ",v=" + this.hV; var t = this.hV.length / 2, e = t.toString(16); if (e.length % 2 == 1 && (e = "0" + e), t < 128) return e; var i = e.length / 2; if (i > 15) throw "ASN.1 length too long to represent by 8x: n = " + t.toString(16); return (128 + i).toString(16) + e }, this.getEncodedHex = function () { return (null == this.hTLV || this.isModified) && (this.hV = this.getFreshValueHex(), this.hL = this.getLengthHexFromValue(), this.hTLV = this.hT + this.hL + this.hV, this.isModified = !1), this.hTLV }, this.getValueHex = function () { return this.getEncodedHex(), this.hV }, this.getFreshValueHex = function () { return "" } }, KJUR.asn1.DERAbstractString = function (t) { KJUR.asn1.DERAbstractString.superclass.constructor.call(this), this.getString = function () { return this.s }, this.setString = function (t) { this.hTLV = null, this.isModified = !0, this.s = t, this.hV = stohex(this.s) }, this.setStringHex = function (t) { this.hTLV = null, this.isModified = !0, this.s = null, this.hV = t }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : void 0 !== t.hex && this.setStringHex(t.hex)) }, JSX.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object), KJUR.asn1.DERAbstractTime = function (t) { KJUR.asn1.DERAbstractTime.superclass.constructor.call(this), this.localDateToUTC = function (t) { return utc = t.getTime() + 6e4 * t.getTimezoneOffset(), new Date(utc) }, this.formatDate = function (t, e) { var i = this.zeroPadding, n = this.localDateToUTC(t), r = String(n.getFullYear()); return "utc" == e && (r = r.substr(2, 2)), r + i(String(n.getMonth() + 1), 2) + i(String(n.getDate()), 2) + i(String(n.getHours()), 2) + i(String(n.getMinutes()), 2) + i(String(n.getSeconds()), 2) + "Z" }, this.zeroPadding = function (t, e) { return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t }, this.getString = function () { return this.s }, this.setString = function (t) { this.hTLV = null, this.isModified = !0, this.s = t, this.hV = stohex(this.s) }, this.setByDateValue = function (t, e, i, n, r, s) { var o = new Date(Date.UTC(t, e - 1, i, n, r, s, 0)); this.setByDate(o) }, this.getFreshValueHex = function () { return this.hV } }, JSX.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object), KJUR.asn1.DERAbstractStructured = function (t) { KJUR.asn1.DERAbstractString.superclass.constructor.call(this), this.setByASN1ObjectArray = function (t) { this.hTLV = null, this.isModified = !0, this.asn1Array = t }, this.appendASN1Object = function (t) { this.hTLV = null, this.isModified = !0, this.asn1Array.push(t) }, this.asn1Array = new Array, void 0 !== t && void 0 !== t.array && (this.asn1Array = t.array) }, JSX.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object), KJUR.asn1.DERBoolean = function () { KJUR.asn1.DERBoolean.superclass.constructor.call(this), this.hT = "01", this.hTLV = "0101ff" }, JSX.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object), KJUR.asn1.DERInteger = function (t) { KJUR.asn1.DERInteger.superclass.constructor.call(this), this.hT = "02", this.setByBigInteger = function (t) { this.hTLV = null, this.isModified = !0, this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t) }, this.setByInteger = function (t) { var e = new BigInteger(String(t), 10); this.setByBigInteger(e) }, this.setValueHex = function (t) { this.hV = t }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.bigint ? this.setByBigInteger(t.bigint) : void 0 !== t.int ? this.setByInteger(t.int) : void 0 !== t.hex && this.setValueHex(t.hex)) }, JSX.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object), KJUR.asn1.DERBitString = function (t) { KJUR.asn1.DERBitString.superclass.constructor.call(this), this.hT = "03", this.setHexValueIncludingUnusedBits = function (t) { this.hTLV = null, this.isModified = !0, this.hV = t }, this.setUnusedBitsAndHexValue = function (t, e) { if (t < 0 || 7 < t) throw "unused bits shall be from 0 to 7: u = " + t; var i = "0" + t; this.hTLV = null, this.isModified = !0, this.hV = i + e }, this.setByBinaryString = function (t) { var e = 8 - (t = t.replace(/0+$/, "")).length % 8; 8 == e && (e = 0); for (var i = 0; i <= e; i++)t += "0"; var n = ""; for (i = 0; i < t.length - 1; i += 8) { var r = t.substr(i, 8), s = parseInt(r, 2).toString(16); 1 == s.length && (s = "0" + s), n += s } this.hTLV = null, this.isModified = !0, this.hV = "0" + e + n }, this.setByBooleanArray = function (t) { for (var e = "", i = 0; i < t.length; i++)1 == t[i] ? e += "1" : e += "0"; this.setByBinaryString(e) }, this.newFalseArray = function (t) { for (var e = new Array(t), i = 0; i < t; i++)e[i] = !1; return e }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.hex ? this.setHexValueIncludingUnusedBits(t.hex) : void 0 !== t.bin ? this.setByBinaryString(t.bin) : void 0 !== t.array && this.setByBooleanArray(t.array)) }, JSX.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object), KJUR.asn1.DEROctetString = function (t) { KJUR.asn1.DEROctetString.superclass.constructor.call(this, t), this.hT = "04" }, JSX.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString), KJUR.asn1.DERNull = function () { KJUR.asn1.DERNull.superclass.constructor.call(this), this.hT = "05", this.hTLV = "0500" }, JSX.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object), KJUR.asn1.DERObjectIdentifier = function (t) { var e = function (t) { var e = t.toString(16); return 1 == e.length && (e = "0" + e), e }, i = function (t) { var i = "", n = new BigInteger(t, 10).toString(2), r = 7 - n.length % 7; 7 == r && (r = 0); for (var s = "", o = 0; o < r; o++)s += "0"; for (n = s + n, o = 0; o < n.length - 1; o += 7) { var h = n.substr(o, 7); o != n.length - 7 && (h = "1" + h), i += e(parseInt(h, 2)) } return i }; KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this), this.hT = "06", this.setValueHex = function (t) { this.hTLV = null, this.isModified = !0, this.s = null, this.hV = t }, this.setValueOidString = function (t) { if (!t.match(/^[0-9.]+$/)) throw "malformed oid string: " + t; var n = "", r = t.split("."), s = 40 * parseInt(r[0]) + parseInt(r[1]); n += e(s), r.splice(0, 2); for (var o = 0; o < r.length; o++)n += i(r[o]); this.hTLV = null, this.isModified = !0, this.s = null, this.hV = n }, this.setValueName = function (t) { if (void 0 === KJUR.asn1.x509.OID.name2oidList[t]) throw "DERObjectIdentifier oidName undefined: " + t; var e = KJUR.asn1.x509.OID.name2oidList[t]; this.setValueOidString(e) }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.oid ? this.setValueOidString(t.oid) : void 0 !== t.hex ? this.setValueHex(t.hex) : void 0 !== t.name && this.setValueName(t.name)) }, JSX.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object), KJUR.asn1.DERUTF8String = function (t) { KJUR.asn1.DERUTF8String.superclass.constructor.call(this, t), this.hT = "0c" }, JSX.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString), KJUR.asn1.DERNumericString = function (t) { KJUR.asn1.DERNumericString.superclass.constructor.call(this, t), this.hT = "12" }, JSX.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString), KJUR.asn1.DERPrintableString = function (t) { KJUR.asn1.DERPrintableString.superclass.constructor.call(this, t), this.hT = "13" }, JSX.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString), KJUR.asn1.DERTeletexString = function (t) { KJUR.asn1.DERTeletexString.superclass.constructor.call(this, t), this.hT = "14" }, JSX.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString), KJUR.asn1.DERIA5String = function (t) { KJUR.asn1.DERIA5String.superclass.constructor.call(this, t), this.hT = "16" }, JSX.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString), KJUR.asn1.DERUTCTime = function (t) { KJUR.asn1.DERUTCTime.superclass.constructor.call(this, t), this.hT = "17", this.setByDate = function (t) { this.hTLV = null, this.isModified = !0, this.date = t, this.s = this.formatDate(this.date, "utc"), this.hV = stohex(this.s) }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date)) }, JSX.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime), KJUR.asn1.DERGeneralizedTime = function (t) { KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, t), this.hT = "18", this.setByDate = function (t) { this.hTLV = null, this.isModified = !0, this.date = t, this.s = this.formatDate(this.date, "gen"), this.hV = stohex(this.s) }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date)) }, JSX.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime), KJUR.asn1.DERSequence = function (t) { KJUR.asn1.DERSequence.superclass.constructor.call(this, t), this.hT = "30", this.getFreshValueHex = function () { for (var t = "", e = 0; e < this.asn1Array.length; e++)t += this.asn1Array[e].getEncodedHex(); return this.hV = t, this.hV } }, JSX.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured), KJUR.asn1.DERSet = function (t) { KJUR.asn1.DERSet.superclass.constructor.call(this, t), this.hT = "31", this.getFreshValueHex = function () { for (var t = new Array, e = 0; e < this.asn1Array.length; e++) { var i = this.asn1Array[e]; t.push(i.getEncodedHex()) } return t.sort(), this.hV = t.join(""), this.hV } }, JSX.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured), KJUR.asn1.DERTaggedObject = function (t) { KJUR.asn1.DERTaggedObject.superclass.constructor.call(this), this.hT = "a0", this.hV = "", this.isExplicit = !0, this.asn1Object = null, this.setASN1Object = function (t, e, i) { this.hT = e, this.isExplicit = t, this.asn1Object = i, this.isExplicit ? (this.hV = this.asn1Object.getEncodedHex(), this.hTLV = null, this.isModified = !0) : (this.hV = null, this.hTLV = i.getEncodedHex(), this.hTLV = this.hTLV.replace(/^../, e), this.isModified = !1) }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.tag && (this.hT = t.tag), void 0 !== t.explicit && (this.isExplicit = t.explicit), void 0 !== t.obj && (this.asn1Object = t.obj, this.setASN1Object(this.isExplicit, this.hT, this.asn1Object))) }, JSX.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object), function (t) { "use strict"; var e, i = { decode: function (t) { var i; if (void 0 === e) { var n = "0123456789ABCDEF", r = " \f\n\r\t?\u2028\u2029"; for (e = [], i = 0; i < 16; ++i)e[n.charAt(i)] = i; for (n = n.toLowerCase(), i = 10; i < 16; ++i)e[n.charAt(i)] = i; for (i = 0; i < r.length; ++i)e[r.charAt(i)] = -1 } var s = [], o = 0, h = 0; for (i = 0; i < t.length; ++i) { var a = t.charAt(i); if ("=" == a) break; if (-1 != (a = e[a])) { if (void 0 === a) throw "Illegal character at offset " + i; o |= a, ++h >= 2 ? (s[s.length] = o, o = 0, h = 0) : o <<= 4 } } if (h) throw "Hex encoding incomplete: 4 bits missing"; return s } }; window.Hex = i }(), function (t) { "use strict"; var e, i = { decode: function (t) { var i; if (void 0 === e) { var n = "= \f\n\r\t?\u2028\u2029"; for (e = [], i = 0; i < 64; ++i)e["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i)] = i; for (i = 0; i < n.length; ++i)e[n.charAt(i)] = -1 } var r = [], s = 0, o = 0; for (i = 0; i < t.length; ++i) { var h = t.charAt(i); if ("=" == h) break; if (-1 != (h = e[h])) { if (void 0 === h) throw "Illegal character at offset " + i; s |= h, ++o >= 4 ? (r[r.length] = s >> 16, r[r.length] = s >> 8 & 255, r[r.length] = 255 & s, s = 0, o = 0) : s <<= 6 } } switch (o) { case 1: throw "Base64 encoding incomplete: at least 2 bits missing"; case 2: r[r.length] = s >> 10; break; case 3: r[r.length] = s >> 16, r[r.length] = s >> 8 & 255 }return r }, re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/, unarmor: function (t) { var e = i.re.exec(t); if (e) if (e[1]) t = e[1]; else { if (!e[2]) throw "RegExp out of sync"; t = e[2] } return i.decode(t) } }; window.Base64 = i }(), function (t) { "use strict"; var e = function (t, e) { var i = document.createElement(t); return i.className = e, i }, i = function (t) { return document.createTextNode(t) }; function n(t, e) { t instanceof n ? (this.enc = t.enc, this.pos = t.pos) : (this.enc = t, this.pos = e) } function r(t, e, i, n, r) { this.stream = t, this.header = e, this.length = i, this.tag = n, this.sub = r } n.prototype.get = function (t) { if (void 0 === t && (t = this.pos++), t >= this.enc.length) throw "Requesting byte offset " + t + " on a stream of length " + this.enc.length; return this.enc[t] }, n.prototype.hexDigits = "0123456789ABCDEF", n.prototype.hexByte = function (t) { return this.hexDigits.charAt(t >> 4 & 15) + this.hexDigits.charAt(15 & t) }, n.prototype.hexDump = function (t, e, i) { for (var n = "", r = t; r < e; ++r)if (n += this.hexByte(this.get(r)), !0 !== i) switch (15 & r) { case 7: n += "  "; break; case 15: n += "\n"; break; default: n += " " }return n }, n.prototype.parseStringISO = function (t, e) { for (var i = "", n = t; n < e; ++n)i += String.fromCharCode(this.get(n)); return i }, n.prototype.parseStringUTF = function (t, e) { for (var i = "", n = t; n < e;) { var r = this.get(n++); i += r < 128 ? String.fromCharCode(r) : r > 191 && r < 224 ? String.fromCharCode((31 & r) << 6 | 63 & this.get(n++)) : String.fromCharCode((15 & r) << 12 | (63 & this.get(n++)) << 6 | 63 & this.get(n++)) } return i }, n.prototype.parseStringBMP = function (t, e) { for (var i = "", n = t; n < e; n += 2) { var r = this.get(n), s = this.get(n + 1); i += String.fromCharCode((r << 8) + s) } return i }, n.prototype.reTime = /^((?:1[89]|2\d)?\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/, n.prototype.parseTime = function (t, e) { var i = this.parseStringISO(t, e), n = this.reTime.exec(i); return n ? (i = n[1] + "-" + n[2] + "-" + n[3] + " " + n[4], n[5] && (i += ":" + n[5], n[6] && (i += ":" + n[6], n[7] && (i += "." + n[7]))), n[8] && (i += " UTC", "Z" != n[8] && (i += n[8], n[9] && (i += ":" + n[9]))), i) : "Unrecognized time: " + i }, n.prototype.parseInteger = function (t, e) { var i = e - t; if (i > 4) { i <<= 3; var n = this.get(t); if (0 === n) i -= 8; else for (; n < 128;)n <<= 1, --i; return "(" + i + " bit)" } for (var r = 0, s = t; s < e; ++s)r = r << 8 | this.get(s); return r }, n.prototype.parseBitString = function (t, e) { var i = this.get(t), n = (e - t - 1 << 3) - i, r = "(" + n + " bit)"; if (n <= 20) { var s = i; r += " "; for (var o = e - 1; o > t; --o) { for (var h = this.get(o), a = s; a < 8; ++a)r += h >> a & 1 ? "1" : "0"; s = 0 } } return r }, n.prototype.parseOctetString = function (t, e) { var i = e - t, n = "(" + i + " byte) "; i > 100 && (e = t + 100); for (var r = t; r < e; ++r)n += this.hexByte(this.get(r)); return i > 100 && (n += "‚Ä¶"), n }, n.prototype.parseOID = function (t, e) { for (var i = "", n = 0, r = 0, s = t; s < e; ++s) { var o = this.get(s); if (n = n << 7 | 127 & o, r += 7, !(128 & o)) { if ("" === i) { var h = n < 80 ? n < 40 ? 0 : 1 : 2; i = h + "." + (n - 40 * h) } else i += "." + (r >= 31 ? "bigint" : n); n = r = 0 } } return i }, r.prototype.typeName = function () { if (void 0 === this.tag) return "unknown"; var t = this.tag >> 6, e = (this.tag, 31 & this.tag); switch (t) { case 0: switch (e) { case 0: return "EOC"; case 1: return "BOOLEAN"; case 2: return "INTEGER"; case 3: return "BIT_STRING"; case 4: return "OCTET_STRING"; case 5: return "NULL"; case 6: return "OBJECT_IDENTIFIER"; case 7: return "ObjectDescriptor"; case 8: return "EXTERNAL"; case 9: return "REAL"; case 10: return "ENUMERATED"; case 11: return "EMBEDDED_PDV"; case 12: return "UTF8String"; case 16: return "SEQUENCE"; case 17: return "SET"; case 18: return "NumericString"; case 19: return "PrintableString"; case 20: return "TeletexString"; case 21: return "VideotexString"; case 22: return "IA5String"; case 23: return "UTCTime"; case 24: return "GeneralizedTime"; case 25: return "GraphicString"; case 26: return "VisibleString"; case 27: return "GeneralString"; case 28: return "UniversalString"; case 30: return "BMPString"; default: return "Universal_" + e.toString(16) }case 1: return "Application_" + e.toString(16); case 2: return "[" + e + "]"; case 3: return "Private_" + e.toString(16) } }, r.prototype.reSeemsASCII = /^[ -~]+$/, r.prototype.content = function () { if (void 0 === this.tag) return null; var t = this.tag >> 6, e = 31 & this.tag, i = this.posContent(), n = Math.abs(this.length); if (0 !== t) { if (null !== this.sub) return "(" + this.sub.length + " elem)"; var r = this.stream.parseStringISO(i, i + Math.min(n, 100)); return this.reSeemsASCII.test(r) ? r.substring(0, 200) + (r.length > 200 ? "‚Ä¶" : "") : this.stream.parseOctetString(i, i + n) } switch (e) { case 1: return 0 === this.stream.get(i) ? "false" : "true"; case 2: return this.stream.parseInteger(i, i + n); case 3: return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(i, i + n); case 4: return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(i, i + n); case 6: return this.stream.parseOID(i, i + n); case 16: case 17: return "(" + this.sub.length + " elem)"; case 12: return this.stream.parseStringUTF(i, i + n); case 18: case 19: case 20: case 21: case 22: case 26: return this.stream.parseStringISO(i, i + n); case 30: return this.stream.parseStringBMP(i, i + n); case 23: case 24: return this.stream.parseTime(i, i + n) }return null }, r.prototype.toString = function () { return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (null === this.sub ? "null" : this.sub.length) + "]" }, r.prototype.print = function (t) { if (void 0 === t && (t = ""), document.writeln(t + this), null !== this.sub) { t += "  "; for (var e = 0, i = this.sub.length; e < i; ++e)this.sub[e].print(t) } }, r.prototype.toPrettyString = function (t) { void 0 === t && (t = ""); var e = t + this.typeName() + " @" + this.stream.pos; if (this.length >= 0 && (e += "+"), e += this.length, 32 & this.tag ? e += " (constructed)" : 3 != this.tag && 4 != this.tag || null === this.sub || (e += " (encapsulates)"), e += "\n", null !== this.sub) { t += "  "; for (var i = 0, n = this.sub.length; i < n; ++i)e += this.sub[i].toPrettyString(t) } return e }, r.prototype.toDOM = function () { var t = e("div", "node"); t.asn1 = this; var n = e("div", "head"), r = this.typeName().replace(/_/g, " "); n.innerHTML = r; var s = this.content(); if (null !== s) { s = String(s).replace(/</g, "&lt;"); var o = e("span", "preview"); o.appendChild(i(s)), n.appendChild(o) } t.appendChild(n), this.node = t, this.head = n; var h = e("div", "value"); if (r = "Offset: " + this.stream.pos + "<br/>", r += "Length: " + this.header + "+", this.length >= 0 ? r += this.length : r += -this.length + " (undefined)", 32 & this.tag ? r += "<br/>(constructed)" : 3 != this.tag && 4 != this.tag || null === this.sub || (r += "<br/>(encapsulates)"), null !== s && (r += "<br/>Value:<br/><b>" + s + "</b>", "object" == typeof oids && 6 == this.tag)) { var a = oids[s]; a && (a.d && (r += "<br/>" + a.d), a.c && (r += "<br/>" + a.c), a.w && (r += "<br/>(warning!)")) } h.innerHTML = r, t.appendChild(h); var u = e("div", "sub"); if (null !== this.sub) for (var p = 0, c = this.sub.length; p < c; ++p)u.appendChild(this.sub[p].toDOM()); return t.appendChild(u), n.onclick = function () { t.className = "node collapsed" == t.className ? "node" : "node collapsed" }, t }, r.prototype.posStart = function () { return this.stream.pos }, r.prototype.posContent = function () { return this.stream.pos + this.header }, r.prototype.posEnd = function () { return this.stream.pos + this.header + Math.abs(this.length) }, r.prototype.fakeHover = function (t) { this.node.className += " hover", t && (this.head.className += " hover") }, r.prototype.fakeOut = function (t) { var e = / ?hover/; this.node.className = this.node.className.replace(e, ""), t && (this.head.className = this.head.className.replace(e, "")) }, r.prototype.toHexDOM_sub = function (t, n, r, s, o) { if (!(s >= o)) { var h = e("span", n); h.appendChild(i(r.hexDump(s, o))), t.appendChild(h) } }, r.prototype.toHexDOM = function (t) { var n = e("span", "hex"); if (void 0 === t && (t = n), this.head.hexNode = n, this.head.onmouseover = function () { this.hexNode.className = "hexCurrent" }, this.head.onmouseout = function () { this.hexNode.className = "hex" }, n.asn1 = this, n.onmouseover = function () { var e = !t.selected; e && (t.selected = this.asn1, this.className = "hexCurrent"), this.asn1.fakeHover(e) }, n.onmouseout = function () { var e = t.selected == this.asn1; this.asn1.fakeOut(e), e && (t.selected = null, this.className = "hex") }, this.toHexDOM_sub(n, "tag", this.stream, this.posStart(), this.posStart() + 1), this.toHexDOM_sub(n, this.length >= 0 ? "dlen" : "ulen", this.stream, this.posStart() + 1, this.posContent()), null === this.sub) n.appendChild(i(this.stream.hexDump(this.posContent(), this.posEnd()))); else if (this.sub.length > 0) { var r = this.sub[0], s = this.sub[this.sub.length - 1]; this.toHexDOM_sub(n, "intro", this.stream, this.posContent(), r.posStart()); for (var o = 0, h = this.sub.length; o < h; ++o)n.appendChild(this.sub[o].toHexDOM(t)); this.toHexDOM_sub(n, "outro", this.stream, s.posEnd(), this.posEnd()) } return n }, r.prototype.toHexString = function (t) { return this.stream.hexDump(this.posStart(), this.posEnd(), !0) }, r.decodeLength = function (t) { var e = t.get(), i = 127 & e; if (i == e) return i; if (i > 3) throw "Length over 24 bits not supported at position " + (t.pos - 1); if (0 === i) return -1; e = 0; for (var n = 0; n < i; ++n)e = e << 8 | t.get(); return e }, r.hasContent = function (t, e, i) { if (32 & t) return !0; if (t < 3 || t > 4) return !1; var s = new n(i); if (3 == t && s.get(), s.get() >> 6 & 1) return !1; try { var o = r.decodeLength(s); return s.pos - i.pos + o == e } catch (t) { return !1 } }, r.decode = function (t) { t instanceof n || (t = new n(t, 0)); var e = new n(t), i = t.get(), s = r.decodeLength(t), o = t.pos - e.pos, h = null; if (r.hasContent(i, s, t)) { var a = t.pos; if (3 == i && t.get(), h = [], s >= 0) { for (var u = a + s; t.pos < u;)h[h.length] = r.decode(t); if (t.pos != u) throw "Content size is not correct for container starting at offset " + a } else try { for (; ;) { var p = r.decode(t); if (0 === p.tag) break; h[h.length] = p } s = a - t.pos } catch (t) { throw "Exception while decoding undefined length content: " + t } } else t.pos += s; return new r(e, o, s, i, h) }, r.test = function () { for (var t = [{ value: [39], expected: 39 }, { value: [129, 201], expected: 201 }, { value: [131, 254, 220, 186], expected: 16702650 }], e = 0, i = t.length; e < i; ++e) { var s = new n(t[e].value, 0), o = r.decodeLength(s); o != t[e].expected && document.write("In test[" + e + "] expected " + t[e].expected + " got " + o + "\n") } }, window.ASN1 = r }(), window.ASN1.prototype.getHexStringValue = function () { var t = this.toHexString(), e = 2 * this.header, i = 2 * this.length; return t.substr(e, i) }, RSAKey.prototype.parseKey = function (t) { try { var e = 0, i = 0, n = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t) ? Hex.decode(t) : window.Base64.unarmor(t), r = window.ASN1.decode(n); if (3 === r.sub.length && (r = r.sub[2].sub[0]), 9 === r.sub.length) { e = r.sub[1].getHexStringValue(), this.n = parseBigInt(e, 16), i = r.sub[2].getHexStringValue(), this.e = parseInt(i, 16); var s = r.sub[3].getHexStringValue(); this.d = parseBigInt(s, 16); var o = r.sub[4].getHexStringValue(); this.p = parseBigInt(o, 16); var h = r.sub[5].getHexStringValue(); this.q = parseBigInt(h, 16); var a = r.sub[6].getHexStringValue(); this.dmp1 = parseBigInt(a, 16); var u = r.sub[7].getHexStringValue(); this.dmq1 = parseBigInt(u, 16); var p = r.sub[8].getHexStringValue(); this.coeff = parseBigInt(p, 16) } else { if (2 !== r.sub.length) return !1; var c = r.sub[1].sub[0]; e = c.sub[0].getHexStringValue(), this.n = parseBigInt(e, 16), i = c.sub[1].getHexStringValue(), this.e = parseInt(i, 16) } return !0 } catch (t) { return !1 } }, RSAKey.prototype.getPrivateBaseKey = function () { var t = { array: [new KJUR.asn1.DERInteger({ int: 0 }), new KJUR.asn1.DERInteger({ bigint: this.n }), new KJUR.asn1.DERInteger({ int: this.e }), new KJUR.asn1.DERInteger({ bigint: this.d }), new KJUR.asn1.DERInteger({ bigint: this.p }), new KJUR.asn1.DERInteger({ bigint: this.q }), new KJUR.asn1.DERInteger({ bigint: this.dmp1 }), new KJUR.asn1.DERInteger({ bigint: this.dmq1 }), new KJUR.asn1.DERInteger({ bigint: this.coeff })] }; return new KJUR.asn1.DERSequence(t).getEncodedHex() }, RSAKey.prototype.getPrivateBaseKeyB64 = function () { return hex2b64(this.getPrivateBaseKey()) }, RSAKey.prototype.getPublicBaseKey = function () { var t = { array: [new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }), new KJUR.asn1.DERNull] }, e = new KJUR.asn1.DERSequence(t); return t = { array: [new KJUR.asn1.DERInteger({ bigint: this.n }), new KJUR.asn1.DERInteger({ int: this.e })] }, t = { hex: "00" + new KJUR.asn1.DERSequence(t).getEncodedHex() }, t = { array: [e, new KJUR.asn1.DERBitString(t)] }, new KJUR.asn1.DERSequence(t).getEncodedHex() }, RSAKey.prototype.getPublicBaseKeyB64 = function () { return hex2b64(this.getPublicBaseKey()) }, RSAKey.prototype.wordwrap = function (t, e) { if (!t) return t; var i = "(.{1," + (e = e || 64) + "})( +|$\n?)|(.{1," + e + "})"; return t.match(RegExp(i, "g")).join("\n") }, RSAKey.prototype.getPrivateKey = function () { var t = "-----BEGIN RSA PRIVATE KEY-----\n"; return (t += this.wordwrap(this.getPrivateBaseKeyB64()) + "\n") + "-----END RSA PRIVATE KEY-----" }, RSAKey.prototype.getPublicKey = function () { var t = "-----BEGIN PUBLIC KEY-----\n"; return (t += this.wordwrap(this.getPublicBaseKeyB64()) + "\n") + "-----END PUBLIC KEY-----" }, RSAKey.prototype.hasPublicKeyProperty = function (t) { return (t = t || {}).hasOwnProperty("n") && t.hasOwnProperty("e") }, RSAKey.prototype.hasPrivateKeyProperty = function (t) { return (t = t || {}).hasOwnProperty("n") && t.hasOwnProperty("e") && t.hasOwnProperty("d") && t.hasOwnProperty("p") && t.hasOwnProperty("q") && t.hasOwnProperty("dmp1") && t.hasOwnProperty("dmq1") && t.hasOwnProperty("coeff") }, RSAKey.prototype.parsePropertiesFrom = function (t) { this.n = t.n, this.e = t.e, t.hasOwnProperty("d") && (this.d = t.d, this.p = t.p, this.q = t.q, this.dmp1 = t.dmp1, this.dmq1 = t.dmq1, this.coeff = t.coeff) }; var JSEncryptRSAKey = function (t) { RSAKey.call(this), t && ("string" == typeof t ? this.parseKey(t) : (this.hasPrivateKeyProperty(t) || this.hasPublicKeyProperty(t)) && this.parsePropertiesFrom(t)) }; JSEncryptRSAKey.prototype = new RSAKey, JSEncryptRSAKey.prototype.constructor = JSEncryptRSAKey; var JSEncrypt = function (t) { t = t || {}, this.default_key_size = parseInt(t.default_key_size) || 1024, this.default_public_exponent = t.default_public_exponent || "010001", this.log = t.log || !1, this.key = null }; JSEncrypt.prototype.setKey = function (t) { this.log && this.key && console.warn("A key was already set, overriding existing."), this.key = new JSEncryptRSAKey(t) }, JSEncrypt.prototype.setPrivateKey = function (t) { this.setKey(t) }, JSEncrypt.prototype.setPublicKey = function (t) { this.setKey(t) }, JSEncrypt.prototype.private_decrypt = function (t) { try { return this.getKey().decrypt_private(b64tohex(t)) } catch (t) { return !1 } }, JSEncrypt.prototype.public_decrypt = function (t) { try { return this.getKey().decrypt_public(b64tohex(t)) } catch (t) { return !1 } }, JSEncrypt.prototype.public_encrypt = function (t) { try { return hex2b64(this.getKey().encrypt_public(t)) } catch (t) { return !1 } }, JSEncrypt.prototype.private_encrypt = function (t) { try { return hex2b64(this.getKey().encrypt_private(t)) } catch (t) { return !1 } }, JSEncrypt.prototype.setPublic = RSASetPublic, JSEncrypt.prototype.getKey = function (t) { if (!this.key) { if (this.key = new JSEncryptRSAKey, t && "[object Function]" === {}.toString.call(t)) return void this.key.generateAsync(this.default_key_size, this.default_public_exponent, t); this.key.generate(this.default_key_size, this.default_public_exponent) } return this.key }, JSEncrypt.prototype.getPrivateKey = function () { return this.getKey().getPrivateKey() }, JSEncrypt.prototype.getPrivateKeyB64 = function () { return this.getKey().getPrivateBaseKeyB64() }, JSEncrypt.prototype.getPublicKey = function () { return this.getKey().getPublicKey() }, JSEncrypt.prototype.getPublicKeyB64 = function () { return this.getKey().getPublicBaseKeyB64() }, JSEncrypt.prototype.setPrivate = RSASetPrivate, JSEncrypt.prototype.setPrivateEx = RSASetPrivateEx, JSEncrypt.prototype.public_encryptLong = function (string, padding, output) { var k = this.getKey(), maxLength = (k.n.bitLength() + 7 >> 3) - 11; try { var lt = "", ct = ""; if (string.length > maxLength) return lt = string.match(eval("/.{1," + maxLength + "}/g")), lt.forEach(function (t) { var e = k.encrypt_public(t, padding); ct += e }), output ? hex2b64(ct) : ct; var t = k.encrypt_public(string, padding), y = output ? hex2b64(t) : t; return y } catch (t) { return !1 } }, JSEncrypt.prototype.private_decryptLong = function (string, padding, output) { var k = this.getKey(), maxLength = (k.n.bitLength() + 7 >> 3) - 11, MAX_DECRYPT_BLOCK = parseInt((k.n.bitLength() + 1) / 4); try { var ct = ""; if (string = output ? b64tohex(string) : string, string.length > maxLength) { var lt = string.match(eval("/.{1," + MAX_DECRYPT_BLOCK + "}/g")); return lt.forEach(function (t) { var e = k.decrypt_private(t, padding); ct += e }), ct } var y = k.decrypt_private(string, padding); return y } catch (t) { return !1 } }, JSEncrypt.prototype.private_encryptLong = function (string, padding, output) { var k = this.getKey(), maxLength = (k.n.bitLength() + 7 >> 3) - 11; try { var lt = "", ct = ""; if (string.length > maxLength) return lt = string.match(eval("/.{1," + maxLength + "}/g")), lt.forEach(function (t) { var e = k.encrypt_private(t, padding); ct += e }), output ? hex2b64(ct) : ct; var t = k.encrypt_private(string, padding), y = output ? hex2b64(t) : t; return y } catch (t) { return !1 } }, JSEncrypt.prototype.public_decryptLong = function (string, padding, output) { var k = this.getKey(), maxLength = (k.n.bitLength() + 7 >> 3) - 11, MAX_DECRYPT_BLOCK = parseInt((k.n.bitLength() + 1) / 4); try { var ct = ""; if (string = output ? b64tohex(string) : string, string.length > maxLength) { var lt = string.match(eval("/.{1," + MAX_DECRYPT_BLOCK + "}/g")); return lt.forEach(function (t) { var e = k.decrypt_public(t, padding); ct += e }), ct } var y = k.decrypt_public(string, padding); return y } catch (t) { return !1 } }, JSEncrypt.version = "2.3.0", exports.JSEncrypt = JSEncrypt }(RSA) } function RSA_Public_Encrypt(t) { var e = new RSA.JSEncrypt; return e.setPublicKey("-----BEGIN PUBLIC KEY-----\nMIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgE8/mRyYJwyMjSGNL9ClZzkly2+S\noSXiPcyH6t2sfmgpgJEn9uuQRG+VeBIaAurtfkGxwb+gzY2dEJED1KhZtj/H5koP\nhZq5MnJuAEDE6YlL61ELJY5PPRWPl2MO5aWsaX32dfXlrdDsKx+UlLbwDjagMVo0\nZ/GiODO6yGbYp8wZAgMBAAE=\n-----END PUBLIC KEY-----"), e.public_encryptLong(t, 2, !0) }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ENV
function Env(t, e) { class s { constructor(t) { this.env = t } send(t, e = "GET") { t = "string" == typeof t ? { url: t } : t; let s = this.get; return "POST" === e && (s = this.post), new Promise((e, a) => { s.call(this, t, (t, s, r) => { t ? a(t) : e(s) }) }) } get(t) { return this.send.call(this.env, t) } post(t) { return this.send.call(this.env, t, "POST") } } return new class { constructor(t, e) { this.name = t, this.http = new s(this), this.data = null, this.dataFile = "box.dat", this.logs = [], this.isMute = !1, this.isNeedRewrite = !1, this.logSeparator = "\n", this.encoding = "utf-8", this.startTime = (new Date).getTime(), Object.assign(this, e), this.log("", `üîî${this.name}, ÂºÄÂßã!`) } getEnv() { return "undefined" != typeof $environment && $environment["surge-version"] ? "Surge" : "undefined" != typeof $environment && $environment["stash-version"] ? "Stash" : "undefined" != typeof module && module.exports ? "Node.js" : "undefined" != typeof $task ? "Quantumult X" : "undefined" != typeof $loon ? "Loon" : "undefined" != typeof $rocket ? "Shadowrocket" : void 0 } isNode() { return "Node.js" === this.getEnv() } isQuanX() { return "Quantumult X" === this.getEnv() } isSurge() { return "Surge" === this.getEnv() } isLoon() { return "Loon" === this.getEnv() } isShadowrocket() { return "Shadowrocket" === this.getEnv() } isStash() { return "Stash" === this.getEnv() } toObj(t, e = null) { try { return JSON.parse(t) } catch { return e } } toStr(t, e = null) { try { return JSON.stringify(t) } catch { return e } } getjson(t, e) { let s = e; const a = this.getdata(t); if (a) try { s = JSON.parse(this.getdata(t)) } catch { } return s } setjson(t, e) { try { return this.setdata(JSON.stringify(t), e) } catch { return !1 } } getScript(t) { return new Promise(e => { this.get({ url: t }, (t, s, a) => e(a)) }) } runScript(t, e) { return new Promise(s => { let a = this.getdata("@chavy_boxjs_userCfgs.httpapi"); a = a ? a.replace(/\n/g, "").trim() : a; let r = this.getdata("@chavy_boxjs_userCfgs.httpapi_timeout"); r = r ? 1 * r : 20, r = e && e.timeout ? e.timeout : r; const [i, o] = a.split("@"), n = { url: `http://${o}/v1/scripting/evaluate`, body: { script_text: t, mock_type: "cron", timeout: r }, headers: { "X-Key": i, Accept: "*/*" }, timeout: r }; this.post(n, (t, e, a) => s(a)) }).catch(t => this.logErr(t)) } loaddata() { if (!this.isNode()) return {}; { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const t = this.path.resolve(this.dataFile), e = this.path.resolve(process.cwd(), this.dataFile), s = this.fs.existsSync(t), a = !s && this.fs.existsSync(e); if (!s && !a) return {}; { const a = s ? t : e; try { return JSON.parse(this.fs.readFileSync(a)) } catch (t) { return {} } } } } writedata() { if (this.isNode()) { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const t = this.path.resolve(this.dataFile), e = this.path.resolve(process.cwd(), this.dataFile), s = this.fs.existsSync(t), a = !s && this.fs.existsSync(e), r = JSON.stringify(this.data); s ? this.fs.writeFileSync(t, r) : a ? this.fs.writeFileSync(e, r) : this.fs.writeFileSync(t, r) } } lodash_get(t, e, s) { const a = e.replace(/\[(\d+)\]/g, ".$1").split("."); let r = t; for (const t of a) if (r = Object(r)[t], void 0 === r) return s; return r } lodash_set(t, e, s) { return Object(t) !== t ? t : (Array.isArray(e) || (e = e.toString().match(/[^.[\]]+/g) || []), e.slice(0, -1).reduce((t, s, a) => Object(t[s]) === t[s] ? t[s] : t[s] = Math.abs(e[a + 1]) >> 0 == +e[a + 1] ? [] : {}, t)[e[e.length - 1]] = s, t) } getdata(t) { let e = this.getval(t); if (/^@/.test(t)) { const [, s, a] = /^@(.*?)\.(.*?)$/.exec(t), r = s ? this.getval(s) : ""; if (r) try { const t = JSON.parse(r); e = t ? this.lodash_get(t, a, "") : e } catch (t) { e = "" } } return e } setdata(t, e) { let s = !1; if (/^@/.test(e)) { const [, a, r] = /^@(.*?)\.(.*?)$/.exec(e), i = this.getval(a), o = a ? "null" === i ? null : i || "{}" : "{}"; try { const e = JSON.parse(o); this.lodash_set(e, r, t), s = this.setval(JSON.stringify(e), a) } catch (e) { const i = {}; this.lodash_set(i, r, t), s = this.setval(JSON.stringify(i), a) } } else s = this.setval(t, e); return s } getval(t) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.read(t); case "Quantumult X": return $prefs.valueForKey(t); case "Node.js": return this.data = this.loaddata(), this.data[t]; default: return this.data && this.data[t] || null } } setval(t, e) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.write(t, e); case "Quantumult X": return $prefs.setValueForKey(t, e); case "Node.js": return this.data = this.loaddata(), this.data[e] = t, this.writedata(), !0; default: return this.data && this.data[e] || null } } initGotEnv(t) { this.got = this.got ? this.got : require("got"), this.cktough = this.cktough ? this.cktough : require("tough-cookie"), this.ckjar = this.ckjar ? this.ckjar : new this.cktough.CookieJar, t && (t.headers = t.headers ? t.headers : {}, void 0 === t.headers.Cookie && void 0 === t.cookieJar && (t.cookieJar = this.ckjar)) } get(t, e = (() => { })) { switch (t.headers && (delete t.headers["Content-Type"], delete t.headers["Content-Length"], delete t.headers["content-type"], delete t.headers["content-length"]), t.params && (t.url += "?" + this.queryStr(t.params)), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() && this.isNeedRewrite && (t.headers = t.headers || {}, Object.assign(t.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient.get(t, (t, s, a) => { !t && s && (s.body = a, s.statusCode = s.status ? s.status : s.statusCode, s.status = s.statusCode), e(t, s, a) }); break; case "Quantumult X": this.isNeedRewrite && (t.opts = t.opts || {}, Object.assign(t.opts, { hints: !1 })), $task.fetch(t).then(t => { const { statusCode: s, statusCode: a, headers: r, body: i, bodyBytes: o } = t; e(null, { status: s, statusCode: a, headers: r, body: i, bodyBytes: o }, i, o) }, t => e(t && t.error || "UndefinedError")); break; case "Node.js": let s = require("iconv-lite"); this.initGotEnv(t), this.got(t).on("redirect", (t, e) => { try { if (t.headers["set-cookie"]) { const s = t.headers["set-cookie"].map(this.cktough.Cookie.parse).toString(); s && this.ckjar.setCookieSync(s, null), e.cookieJar = this.ckjar } } catch (t) { this.logErr(t) } }).then(t => { const { statusCode: a, statusCode: r, headers: i, rawBody: o } = t, n = s.decode(o, this.encoding); e(null, { status: a, statusCode: r, headers: i, rawBody: o, body: n }, n) }, t => { const { message: a, response: r } = t; e(a, r, r && s.decode(r.rawBody, this.encoding)) }) } } post(t, e = (() => { })) { const s = t.method ? t.method.toLocaleLowerCase() : "post"; switch (t.body && t.headers && !t.headers["Content-Type"] && !t.headers["content-type"] && (t.headers["content-type"] = "application/x-www-form-urlencoded"), t.headers && (delete t.headers["Content-Length"], delete t.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() && this.isNeedRewrite && (t.headers = t.headers || {}, Object.assign(t.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient[s](t, (t, s, a) => { !t && s && (s.body = a, s.statusCode = s.status ? s.status : s.statusCode, s.status = s.statusCode), e(t, s, a) }); break; case "Quantumult X": t.method = s, this.isNeedRewrite && (t.opts = t.opts || {}, Object.assign(t.opts, { hints: !1 })), $task.fetch(t).then(t => { const { statusCode: s, statusCode: a, headers: r, body: i, bodyBytes: o } = t; e(null, { status: s, statusCode: a, headers: r, body: i, bodyBytes: o }, i, o) }, t => e(t && t.error || "UndefinedError")); break; case "Node.js": let a = require("iconv-lite"); this.initGotEnv(t); const { url: r, ...i } = t; this.got[s](r, i).then(t => { const { statusCode: s, statusCode: r, headers: i, rawBody: o } = t, n = a.decode(o, this.encoding); e(null, { status: s, statusCode: r, headers: i, rawBody: o, body: n }, n) }, t => { const { message: s, response: r } = t; e(s, r, r && a.decode(r.rawBody, this.encoding)) }) } } time(t, e = null) { const s = e ? new Date(e) : new Date; let a = { "M+": s.getMonth() + 1, "d+": s.getDate(), "H+": s.getHours(), "m+": s.getMinutes(), "s+": s.getSeconds(), "q+": Math.floor((s.getMonth() + 3) / 3), S: s.getMilliseconds() }; /(y+)/.test(t) && (t = t.replace(RegExp.$1, (s.getFullYear() + "").substr(4 - RegExp.$1.length))); for (let e in a) new RegExp("(" + e + ")").test(t) && (t = t.replace(RegExp.$1, 1 == RegExp.$1.length ? a[e] : ("00" + a[e]).substr(("" + a[e]).length))); return t } queryStr(t) { let e = ""; for (const s in t) { let a = t[s]; null != a && "" !== a && ("object" == typeof a && (a = JSON.stringify(a)), e += `${s}=${a}&`) } return e = e.substring(0, e.length - 1), e } msg(e = t, s = "", a = "", r) { const i = t => { switch (typeof t) { case void 0: return t; case "string": switch (this.getEnv()) { case "Surge": case "Stash": default: return { url: t }; case "Loon": case "Shadowrocket": return t; case "Quantumult X": return { "open-url": t }; case "Node.js": return }case "object": switch (this.getEnv()) { case "Surge": case "Stash": case "Shadowrocket": default: { let e = t.url || t.openUrl || t["open-url"]; return { url: e } } case "Loon": { let e = t.openUrl || t.url || t["open-url"], s = t.mediaUrl || t["media-url"]; return { openUrl: e, mediaUrl: s } } case "Quantumult X": { let e = t["open-url"] || t.url || t.openUrl, s = t["media-url"] || t.mediaUrl, a = t["update-pasteboard"] || t.updatePasteboard; return { "open-url": e, "media-url": s, "update-pasteboard": a } } case "Node.js": return }default: return } }; if (!this.isMute) switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: $notification.post(e, s, a, i(r)); break; case "Quantumult X": $notify(e, s, a, i(r)); break; case "Node.js": }if (!this.isMuteLog) { let t = ["", "==============üì£Á≥ªÁªüÈÄöÁü•üì£=============="]; t.push(e), s && t.push(s), a && t.push(a), console.log(t.join("\n")), this.logs = this.logs.concat(t) } } log(...t) { t.length > 0 && (this.logs = [...this.logs, ...t]), console.log(t.join(this.logSeparator)) } logErr(t, e) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": default: this.log("", `‚ùóÔ∏è${this.name}, ÈîôËØØ!`, t); break; case "Node.js": this.log("", `‚ùóÔ∏è${this.name}, ÈîôËØØ!`, t.stack) } } wait(t) { return new Promise(e => setTimeout(e, t)) } done(t = {}) { const e = (new Date).getTime(), s = (e - this.startTime) / 1e3; switch (this.log("", `üîî${this.name}, ÁªìÊùü! üïõ ${s} Áßí`), this.log(), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": default: $done(t); break; case "Node.js": process.exit(1) } } }(t, e) }
